ca65 V2.18 - Debian 2.19-1
Main file   : m65.a65
Current file: m65.a65

000000r 1               ;
000000r 1               ;----------------------------------------------------------
000000r 1               ; fsm65 fs monitor for 6502
000000r 1               ; Fabio Sturman (c) 2019,20,21,22,23
000000r 1               ; fabio.sturman@gmail.com
000000r 1               ;----------------------------------------------------------
000000r 1               ; a65 - 6502 assembler file
000000r 1               ; i65 - 6502 include file
000000r 1               ; assembled using cc65 suite
000000r 1               ; assembler: ca65
000000r 1               ; linker: ld65
000000r 1               ;----------------------------------------------------------
000000r 1               ; m65.a65 main module
000000r 1               ;----------------------------------------------------------
000000r 1               ; Memory map gal-v1.7:
000000r 1               ; 0000-dfff   ram
000000r 1               ; a000-bfff   8 pages of 8 KiB of paged ram
000000r 1               ; e000-e3ff   i/o
000000r 1               ;   e000-e0ff acia0
000000r 1               ;   e100-e1ff via0
000000r 1               ;   e200-e3ff ide
000000r 1               ; e000-ffff   rom
000000r 1               ;   c000-e3ff masked by i/o 1 kiB
000000r 1               ;   e400-ffff usable rom 7 kiB
000000r 1               ;             programs in 8 kiB rom
000000r 1               ;             must start @ $0400
000000r 1               ;             rom size 8 kiB
000000r 1               ;----------------------------------------------------------
000000r 1               ; via0:
000000r 1               ; acia0:
000000r 1               ; ide0:
000000r 1               ;  see circuit diagram for detalied
000000r 1               ;  description on usage
000000r 1               ;----------------------------------------------------------
000000r 1               ;
000000r 1               		.setcpu "65C02"
000000r 1               		.debuginfo +
000000r 1               		.include "macros.i65"
000000r 2               ;----------------------------------------------------------
000000r 2               ;
000000r 2               ;  mov_ay2x xx
000000r 2               ;
000000r 2                               .macro mov_ay2x xx
000000r 2                               sta xx
000000r 2                               sty xx+1
000000r 2                               .endmacro
000000r 2               ;
000000r 2               ;  mov_ax2x xx
000000r 2               ;
000000r 2                               .macro mov_ax2x xx
000000r 2                               sta xx
000000r 2                               stx xx+1
000000r 2                               .endmacro
000000r 2               ;
000000r 2               ; mov_n2x n16, x  -- low(n16)->x   high(n16)->x+1
000000r 2               ;
000000r 2                               .macro mov_n2x num, xx
000000r 2                               lda #<num
000000r 2                               ldy #>num
000000r 2                               sta xx
000000r 2                               sty xx+1
000000r 2                               .endmacro
000000r 2               ;
000000r 2               ; mov_x2y x, y
000000r 2               ;
000000r 2                               .macro mov_x2y xx, yy
000000r 2                               lda xx
000000r 2                               ldy xx+1
000000r 2                               sta yy
000000r 2                               sty yy+1
000000r 2                               .endmacro
000000r 2               ;
000000r 2               ;  mov_n2ay n
000000r 2               ;
000000r 2                               .macro mov_n2ay num
000000r 2                               lda #<num
000000r 2                               ldy #>num
000000r 2                               .endmacro
000000r 2               ;
000000r 2               ; mov_x2ay  x
000000r 2               ;
000000r 2                               .macro mov_x2ay xx
000000r 2                               lda xx
000000r 2                               ldy xx+1
000000r 2                               .endmacro
000000r 2               ;
000000r 2               ;  mov_n2ax n
000000r 2               ;
000000r 2                               .macro mov_n2ax num
000000r 2                               lda #<num
000000r 2                               ldx #>num
000000r 2                               .endmacro
000000r 2               ;
000000r 2               ; mov_x2ax  x
000000r 2               ;
000000r 2                               .macro mov_x2ax xx
000000r 2                               lda xx
000000r 2                               ldx xx+1
000000r 2                               .endmacro
000000r 2               ;
000000r 2               ; print_s ad
000000r 2               ;
000000r 2                               .macro print_s ad
000000r 2                               lda #<ad
000000r 2                               ldy #>ad
000000r 2                               jsr put_s
000000r 2                               .endmacro
000000r 2               ;
000000r 2               ; print_cr_lf
000000r 2               ;
000000r 2                               .macro print_cr_lf
000000r 2                               jsr put_cr_lf
000000r 2                               .endmacro
000000r 2               ;
000000r 2               ; print_sp
000000r 2               ;
000000r 2                               .macro print_sp
000000r 2                               jsr put_sp
000000r 2                               .endmacro
000000r 2               ;
000000r 2               ; print_w_hex ad
000000r 2               ;
000000r 2                               .macro print_w_hex ad
000000r 2                               lda ad
000000r 2                               ldy ad+1
000000r 2                               jsr put_w_hex
000000r 2                               .endmacro
000000r 2               ;
000000r 2               ; print_c c
000000r 2               ;
000000r 2                               .macro print_c c
000000r 2                               lda #c
000000r 2                               jsr put_c
000000r 2                               .endmacro
000000r 2               ;
000000r 2               ; inc_ptr ptr
000000r 2               ;
000000r 2                               .macro inc_ptr ptr
000000r 2                               .local l1
000000r 2                               inc ptr
000000r 2                               bne l1
000000r 2                               inc ptr+1
000000r 2               l1:
000000r 2                              .endmacro
000000r 2               ;
000000r 2               ; bit_test flag, mask
000000r 2               ;
000000r 2                               .macro bit_test flag, mask
000000r 2                               lda #mask
000000r 2                               and flag
000000r 2                               .endmacro
000000r 2               ;
000000r 2               ; bit_set flag, mask
000000r 2               ;
000000r 2                               .macro bit_set flag, mask
000000r 2                               lda #mask
000000r 2                               ora flag
000000r 2                               sta flag
000000r 2                               .endmacro
000000r 2               ;
000000r 2               ; bit_clear flag, mask
000000r 2               ;
000000r 2                               .macro bit_clear flag, mask
000000r 2                               lda #mask
000000r 2                               eor #$ff
000000r 2                               and flag
000000r 2                               sta flag
000000r 2                               .endmacro
000000r 2               ;
000000r 2               ; inc_x arg1 - increment
000000r 2               ;
000000r 2                               .macro inc_x reg
000000r 2                               ldx #reg
000000r 2                               jsr inc_zz	;reginc
000000r 2                               .endmacro
000000r 2               ;
000000r 2               ; dec_x arg1 - decrement
000000r 2               ;
000000r 2                               .macro dec_x reg
000000r 2                               ldx #reg
000000r 2                               jsr dec_zz		;regdec
000000r 2                               .endmacro
000000r 2               ;
000000r 2               ; test_x arg1 - test if zero
000000r 2               ;
000000r 2                               .macro test_x reg
000000r 2                               ldx #reg
000000r 2                               jsr test_zz		;regzer
000000r 2                               .endmacro
000000r 2               ;
000000r 2                               .macro debug_c c
000000r 2                               php
000000r 2                               pha
000000r 2                               lda #c
000000r 2                               jsr put_c
000000r 2                               pla
000000r 2                               plp
000000r 2                               .endmacro
000000r 2               
000000r 2               
000000r 1               ;
000000r 1               ;----------------------------------------------------------
000000r 1               ; constants and i/o
000000r 1               ;----------------------------------------------------------
000000r 1               ;
000000r 1               DEBUG		= 0
000000r 1               ;
000000r 1               VERSIONH	= 0		;0..9
000000r 1               VERSIONL	= 4		;0..9
000000r 1               ;
000000r 1               CR			= 13
000000r 1               LF			= 10
000000r 1               BS			= 8
000000r 1               DEL			= $7f
000000r 1               ESC			= 27
000000r 1               FF			= 12	;form feed
000000r 1               CTRL_C		= 3		;break
000000r 1               CTRL_P		= 16
000000r 1               CTRL_N		= 14
000000r 1               CTRL_X		= 24	;abort
000000r 1               BREAK_C		= CTRL_C
000000r 1               CTRL_G		= 7
000000r 1               CTRL_T		= 20
000000r 1               CTRL_H		= 8
000000r 1               ;
000000r 1               FLAG_RD		= 16
000000r 1               FLAG_ADD	= 32
000000r 1               FLAG_LEN	= 64
000000r 1               FLAG_DATA	= 128
000000r 1               FLAG_ASCII	= 1
000000r 1               CMD_BUF_LEN	= 81
000000r 1               ;
000000r 1               work_area	= $200
000000r 1               ER_NONE		= 0
000000r 1               ER_LEN		= 1
000000r 1               ;
000000r 1               	.if ROMS = 6
000000r 1               acia0		:= $e400
000000r 1               via0		:= $e500
000000r 1               ide0		:= $e600
000000r 1               	.endif
000000r 1               	.if ROMS = 7
000000r 1               acia0		:= $e000
000000r 1               via0		:= $e100
000000r 1               ide0		:= $e200
000000r 1               	.endif
000000r 1               ;
000000r 1               	.include "via0.i65"
000000r 2               ;via0
000000r 2               portb0	:= via0
000000r 2               orb0	:= via0
000000r 2               irb0	:= via0
000000r 2               porta0	:= via0+1
000000r 2               ora0	:= via0+1
000000r 2               ira0	:= via0+1
000000r 2               ddrb0	:= via0+2
000000r 2               ddra0	:= via0+3
000000r 2               t1cl0	:= via0+4
000000r 2               t1ch0	:= via0+5
000000r 2               t1ll0	:= via0+6
000000r 2               t1lh0	:= via0+7
000000r 2               t2cl0	:= via0+8
000000r 2               t2ch0	:= via0+9
000000r 2               sr0		:= via0+10
000000r 2               acr0	:= via0+11
000000r 2               pcr0	:= via0+12
000000r 2               ifr0	:= via0+13
000000r 2               ier0	:= via0+14
000000r 2               portanh0	:= via0+15
000000r 2               oranh0	:= via0+15
000000r 2               iranh0	:= via0+15
000000r 2               
000000r 2               
000000r 1               	.include "acia0.i65"
000000r 2               ; acia0
000000r 2               acia_data		:= acia0
000000r 2               acia_status		:= acia0+1
000000r 2               acia_reset		:= acia0+1
000000r 2               acia_command	:= acia0+2
000000r 2               acia_control	:= acia0+3
000000r 2               
000000r 2               
000000r 1               ;
000000r 1               ;----------------------------------------------------------
000000r 1               ; sweet16 & monitor zero page
000000r 1               ;----------------------------------------------------------
000000r 1               ;
000000r 1               		.segment "ZEROPAGE"
000000r 1               ; sweet16 d0-ef
000000r 1  xx           r0l:	.res 1
000001r 1  xx           r0h:	.res 1
000002r 1  xx xx xx xx  		.res 27
000006r 1  xx xx xx xx  
00000Ar 1  xx xx xx xx  
00001Dr 1  xx           r14h:	.res 1
00001Er 1  xx           r15l:	.res 1
00001Fr 1  xx           r15h:	.res 1
000020r 1               ; monitor f0-ff
000020r 1  xx xx        ra:		.res 2
000022r 1  xx xx        rb:		.res 2
000024r 1  xx xx        rc:		.res 2
000026r 1  xx xx        rd:		.res 2
000028r 1  xx xx        po:		.res 2
00002Ar 1               ;
00002Ar 1  xx xx        add:	.res 2
00002Cr 1  xx xx        len:	.res 2
00002Er 1  xx xx        data:	.res 2
000030r 1               ;
000030r 1               ;----------------------------------------------------------
000030r 1               ; monitor work memory
000030r 1               ;----------------------------------------------------------
000030r 1               ;
000030r 1               		.segment "BUFFERS"
000000r 1               ;
000000r 1               data_start:
000000r 1               ;
000000r 1  xx xx xx xx  rx_buf:		.res 128
000004r 1  xx xx xx xx  
000008r 1  xx xx xx xx  
000080r 1  xx xx xx xx  tx_buf:		.res 128
000084r 1  xx xx xx xx  
000088r 1  xx xx xx xx  
000100r 1  xx xx xx xx  cmd_buf:	.res CMD_BUF_LEN
000104r 1  xx xx xx xx  
000108r 1  xx xx xx xx  
000151r 1               ;
000151r 1  xx           rx_cnt:		.res 1
000152r 1  xx           rx_tail:	.res 1
000153r 1  xx           rx_head:	.res 1
000154r 1               ;
000154r 1  xx           tx_cnt:		.res 1
000155r 1  xx           tx_tail:	.res 1
000156r 1  xx           tx_head:	.res 1
000157r 1  xx           breakf:		.res 1	;if<>0 break received
000158r 1  xx           fsmflags:	.res 1
000159r 1  xx           last_cmd:	.res 1
00015Ar 1               ;
00015Ar 1               ; mon
00015Ar 1               ;
00015Ar 1  xx xx        irq_vec:	.res 2
00015Cr 1  xx xx        nmi_vec:	.res 2
00015Er 1  xx xx        brk_vec:	.res 2
000160r 1  xx xx        getc_vec:	.res 2
000162r 1  xx xx        putc_vec:	.res 2
000164r 1  xx xx        jmp_vec:	.res 2
000166r 1               ;
000166r 1  xx           scany:		.res 1
000167r 1  xx xx        count:		.res 2
000169r 1  xx           chk:		.res 1
00016Ar 1  xx xx        flags:		.res 2
00016Cr 1  xx           dout:		.res 1	;acia1
00016Dr 1               ;
00016Dr 1               ; sd disk
00016Dr 1               ;
00016Dr 1  xx xx xx xx  sd_lba:		.res 4
000171r 1  xx           sd_nret:	.res 1
000172r 1  xx xx xx xx  cf_lba:		.res 4
000176r 1               ;
000176r 1               ; rtc
000176r 1               ;
000176r 1               temp:
000176r 1  xx           seconds:	.res 1
000177r 1  xx           minutes:	.res 1
000178r 1  xx           hours:		.res 1
000179r 1  xx           dayweek:	.res 1
00017Ar 1  xx           date:		.res 1
00017Br 1  xx           month:		.res 1
00017Cr 1  xx           year:		.res 1
00017Dr 1  xx           century:	.res 1
00017Er 1               ;
00017Er 1               ; ram registers
00017Er 1               ;
00017Er 1  xx           reg_sp:		.res 1
00017Fr 1  xx xx        reg_pc:		.res 2
000181r 1  xx           reg_cc:		.res 1
000182r 1  xx           reg_x:		.res 1
000183r 1  xx           reg_y:		.res 1
000184r 1  xx           reg_a:		.res 1
000185r 1               ;
000185r 1  xx           timer8_4:	.res 1	; buzzer timer
000186r 1  xx xx xx xx  sys_timer:	.res 4	; system timer
00018Ar 1               ;
00018Ar 1               		.ifdef TIMER8_DEF
00018Ar 1               timer8_0:		.res 1
00018Ar 1               timer8_1:		.res 1
00018Ar 1               timer8_2:		.res 1
00018Ar 1               timer8_3:		.res 1
00018Ar 1               timer8_0_vec:	.res 2
00018Ar 1               timer8_1_vec:	.res 2
00018Ar 1               timer8_2_vec:	.res 2
00018Ar 1               timer8_3_vec:	.res 2
00018Ar 1               		.endif
00018Ar 1               ;
00018Ar 1               data_end:
00018Ar 1               ;
00018Ar 1               ;----------------------------------------------------------
00018Ar 1               ;
00018Ar 1               		.segment "CODE"
000000r 1               ;
000000r 1               code_start:
000000r 1               ;
000000r 1               ; monitor cold entry
000000r 1               ;
000000r 1  4C rr rr     mcld:	jmp cold			;cold entry
000003r 1               ;;mwrm:	jmp warm			;warm entry
000003r 1               ;
000003r 1               sweet_start:
000003r 1               	.include "sweet16.a65"
000003r 2               ;*******************************
000003r 2               ;*                              *
000003r 2               ;*   APPLE-II  PSEUDO MACHINE   *
000003r 2               ;*         INTERPRETER          *
000003r 2               ;*                              *
000003r 2               ;*      COPYRIGHT (C) 1977      *
000003r 2               ;*     APPLE COMPUTER,  INC     *
000003r 2               ;*                              *
000003r 2               ;*     ALL  RIGHTS RESERVED     *
000003r 2               ;*                              *
000003r 2               ;*         S. WOZNIAK           *
000003r 2               ;*                              *
000003r 2               ;********************************
000003r 2               ;*                              *
000003r 2               ;* TITLE:  SWEET 16 INTERPRETER *
000003r 2               ;*                              *
000003r 2               ;********************************
000003r 2               ;
000003r 2               	.segment "BUFFERS"
00018Ar 2               ;
00018Ar 2  xx           savea:	.res 1
00018Br 2  xx           savex:	.res 1
00018Cr 2  xx           savey:	.res 1
00018Dr 2  xx           saves:	.res 1
00018Er 2               ;
00018Er 2               	.segment "CODE"
000003r 2               ;
000003r 2               ; following code must be
000003r 2               ; contained on a single page!
000003r 2               ;
000003r 2               ld:
000003r 2  B5 rr        	lda r0l,x
000005r 2               bk	:= *-1
000005r 2  85 rr        	sta r0l
000007r 2  B5 rr        	lda r0h,x	;move rx to r0
000009r 2  85 rr        	sta r0h
00000Br 2  60           	rts
00000Cr 2               st:
00000Cr 2  A5 rr        	lda r0l
00000Er 2  95 rr        	sta r0l,x	;move r0 to rx
000010r 2  A5 rr        	lda r0h
000012r 2  95 rr        	sta r0h,x
000014r 2  60           	rts
000015r 2               stat:
000015r 2  A5 rr        	lda r0l
000017r 2               stat2:
000017r 2  81 rr        	sta (r0l,x)	;store byte indirect
000019r 2  A0 00        	ldy #0
00001Br 2               stat3:
00001Br 2  84 rr        	sty r14h	;indicate r0 is result neg
00001Dr 2               inr:
00001Dr 2  F6 rr        	inc r0l,x
00001Fr 2  D0 02        	bne inr2	;incr rx
000021r 2  F6 rr        	inc r0h,x
000023r 2               inr2:
000023r 2  60           	rts
000024r 2               ldat:
000024r 2  A1 rr        	lda (r0l,x)	;load indirect (rx)
000026r 2  85 rr        	sta r0l		;to r0
000028r 2  A0 00        	ldy #0
00002Ar 2  84 rr        	sty r0h	;sty r0h		;zero high order r0 byte
00002Cr 2  F0 ED        	beq stat3	;always taken
00002Er 2               pop:
00002Er 2  A0 00        	ldy #0		;high order byte = 0
000030r 2  F0 06        	beq pop2	;always taken
000032r 2               popd:
000032r 2  20 rr rr     	jsr dcr		;decr rx
000035r 2  A1 rr        	lda (r0l,x)	;pop high order byte @rx
000037r 2  A8           	tay			;save in y reg
000038r 2               pop2:
000038r 2  20 rr rr     	jsr dcr		;decr rx
00003Br 2  A1 rr        	lda (r0l,x)	;low order byte
00003Dr 2  85 rr        	sta r0l		;to r0
00003Fr 2  84 rr        	sty r0h
000041r 2               pop3:
000041r 2  A0 00        	ldy #0		;<--- indicate r0 as last result reg
000043r 2  84 rr        	sty r14h
000045r 2  60           	rts
000046r 2               lddat:
000046r 2  20 rr rr     	jsr ldat	;low order byte to r0, incr rx
000049r 2  A1 rr        	lda (r0l,x)	;high order byte to r0
00004Br 2  85 rr        	sta r0h
00004Dr 2  4C rr rr     	jmp inr		;incr rx
000050r 2               stdat:
000050r 2  20 rr rr     	jsr stat	;store indirect low order
000053r 2  A5 rr        	lda r0h		;byte and incr rx. then
000055r 2  81 rr        	sta (r0l,x)	;store high order byte.
000057r 2  4C rr rr     	jmp  inr	;incr rx and return
00005Ar 2               stpat:
00005Ar 2  20 rr rr     	jsr dcr		;decr rx
00005Dr 2  A5 rr        	lda r0l
00005Fr 2  81 rr        	sta (r0l,x)	;store r0 low byte @rx
000061r 2  4C rr rr     	jmp pop3	;indicate r0 as last result reg
000064r 2               dcr:
000064r 2  B5 rr        	lda r0l,x
000066r 2  D0 02        	bne dcr2	;decr rx
000068r 2  D6 rr        	dec r0h,x
00006Ar 2               dcr2:
00006Ar 2  D6 rr        	dec r0l,x
00006Cr 2  60           	rts
00006Dr 2               sub:
00006Dr 2  A0 00        	ldy #0		;result to r0
00006Fr 2               cpr:
00006Fr 2  38           	sec			;note y reg = 13*2 for cpr
000070r 2  A5 rr        	lda r0l
000072r 2  F5 rr        	sbc r0l,x
000074r 2  99 rr rr     	sta r0l,y	;r0-rx to ry
000077r 2  A5 rr        	lda r0h
000079r 2  F5 rr        	sbc r0h,x
00007Br 2               sub2:
00007Br 2  99 rr rr     	sta r0h,y
00007Er 2  98           	tya			;last result reg*2
00007Fr 2  69 00        	adc #0		;carry to lsb
000081r 2  85 rr        	sta r14h
000083r 2  60           	rts
000084r 2               addi:
000084r 2  A5 rr        	lda r0l
000086r 2  75 rr        	adc r0l,x
000088r 2  85 rr        	sta r0l		;r0+rx to r0
00008Ar 2  A5 rr        	lda r0h
00008Cr 2  75 rr        	adc r0h,x
00008Er 2  A0 00        	ldy #0		;r0 for result
000090r 2  F0 E9        	beq sub2	;finish add
000092r 2               bs:
000092r 2  A5 rr        	lda r15l	;note x reg is 12*2!
000094r 2  20 rr rr     	jsr stat2	;push low pc byte via r12
000097r 2  A5 rr        	lda r15h
000099r 2  20 rr rr     	jsr stat2	;push high order pc byte
00009Cr 2               br:
00009Cr 2  18           	clc
00009Dr 2               bnc:
00009Dr 2  B0 0E        	bcs bnc2	;no carry test
00009Fr 2               br1:
00009Fr 2  B1 rr        	lda (r15l),y	;displacement byte
0000A1r 2  10 01        	bpl br2
0000A3r 2  88           	dey
0000A4r 2               br2:
0000A4r 2  65 rr        	adc r15l	;add to pc
0000A6r 2  85 rr        	sta r15l
0000A8r 2  98           	tya
0000A9r 2  65 rr        	adc r15h
0000ABr 2  85 rr        	sta r15h
0000ADr 2               bnc2:
0000ADr 2  60           	rts
0000AEr 2               bc:
0000AEr 2  B0 EC        	bcs br
0000B0r 2  60           	rts
0000B1r 2               bp:
0000B1r 2  0A           	asl			;double result-reg index
0000B2r 2  AA           	tax			;to x reg for indexing
0000B3r 2  B5 rr        	lda r0h,x	;test for plus
0000B5r 2  10 E8        	bpl br1		;branch if so
0000B7r 2  60           	rts
0000B8r 2               bm:
0000B8r 2  0A           	asl			;double result-reg index
0000B9r 2  AA           	tax
0000BAr 2  B5 rr        	lda r0h,x	;test for minus
0000BCr 2  30 E1        	bmi br1
0000BEr 2  60           	rts
0000BFr 2               bz:
0000BFr 2  0A           	asl			;double result-reg index
0000C0r 2  AA           	tax
0000C1r 2  B5 rr        	lda r0l,x	;test for zero
0000C3r 2  15 rr        	ora r0h,x	;(both bytes)
0000C5r 2  F0 D8        	beq br1		;branch if so
0000C7r 2  60           	rts
0000C8r 2               bnz:
0000C8r 2  0A           	asl                 ;double result-reg index
0000C9r 2  AA           	tax
0000CAr 2  B5 rr        	lda r0l,x          ;test for non-zero
0000CCr 2  15 rr        	ora r0h,x          ;(both bytes)
0000CEr 2  D0 CF        	bne br1            ;branch if so
0000D0r 2  60           	rts
0000D1r 2               bm1:
0000D1r 2  0A           	asl                 ;double result-reg index
0000D2r 2  AA           	tax
0000D3r 2  B5 rr        	lda r0l,x          ;check both bytes
0000D5r 2  35 rr        	and r0h,x          ;for $ff (minus 1)
0000D7r 2  49 FF        	eor #$ff
0000D9r 2  F0 C4        	beq br1            ;branch if so
0000DBr 2  60           	rts
0000DCr 2               bnm1:
0000DCr 2  0A           	asl                 ;double result-reg index
0000DDr 2  AA           	tax
0000DEr 2  B5 rr        	lda r0l,x
0000E0r 2  35 rr        	and r0h,x          ;check both bytes for no $ff
0000E2r 2  49 FF        	eor #$ff
0000E4r 2  D0 B9        	bne br1            ;branch if not minus 1
0000E6r 2               nul:
0000E6r 2  60           	rts
0000E7r 2               rs:
0000E7r 2  A2 18        	ldx #$18            ;12*2 for r12 as stack pointer
0000E9r 2  20 rr rr     	jsr dcr            ;decr stack pointer
0000ECr 2  A1 rr        	lda (r0l,x)        ;pop high return address to pc
0000EEr 2  85 rr        	sta r15h
0000F0r 2  20 rr rr     	jsr dcr            ;same for low order byte
0000F3r 2  A1 rr        	lda (r0l,x)
0000F5r 2  85 rr        	sta r15l
0000F7r 2  60           	rts
0000F8r 2               rtn:
0000F8r 2  4C rr rr     	jmp rtnz
0000FBr 2               set:
0000FBr 2  10 45        	bpl setz
0000FDr 2               ;
0000FDr 2               ; sweet16 entry point
0000FDr 2               ;
0000FDr 2               msw16:
0000FDr 2               sw16:
0000FDr 2  20 rr rr     	jsr save           ;preserve 6502 reg contents
000100r 2  68           	pla
000101r 2  85 rr        	sta r15l           ;init sweet16 pc
000103r 2  68           	pla                 ;from return
000104r 2  85 rr        	sta r15h           ;address
000106r 2               sw16b:
000106r 2  20 rr rr     	jsr sw16c          ;interpret and execute
000109r 2  80 FB        	bra sw16b          ;one sweet16 instr.
00010Br 2               sw16c:
00010Br 2  E6 rr        	inc r15l
00010Dr 2  D0 02        	bne sw16d          ;incr sweet16 pc for fetch
00010Fr 2  E6 rr        	inc r15h
000111r 2               sw16d:
000111r 2  A9 rr        	lda #>ld           ;common high byte for all routines
000113r 2  48           	pha                 ;push on stack for rts
000114r 2  A0 00        	ldy #0
000116r 2  B1 rr        	lda (r15l),y       ;fetch instr
000118r 2  29 0F        	and #$f             ;mask reg specification
00011Ar 2  0A           	asl                 ;double for two byte registers
00011Br 2  AA           	tax                 ;to x reg for indexing
00011Cr 2  4A           	lsr
00011Dr 2  51 rr        	eor (r15l),y       ;now have opcode
00011Fr 2  F0 0B        	beq tobr           ;if zero then non-reg op
000121r 2  86 rr        	stx r14h           ;indicate "prior result reg"
000123r 2  4A           	lsr
000124r 2  4A           	lsr                 ;opcode*2 to lsb's
000125r 2  4A           	lsr
000126r 2  A8           	tay                 ;to y reg for indexing
000127r 2  B9 rr rr     	lda optbl-2,y      ;low order adr byte
00012Ar 2  48           	pha                 ;onto stack
00012Br 2  60           	rts                 ;goto reg-op routine
00012Cr 2               tobr:
00012Cr 2  E6 rr        	inc r15l
00012Er 2  D0 02        	bne tobr2          ;incr pc
000130r 2  E6 rr        	inc r15h
000132r 2               tobr2:
000132r 2  BD rr rr     	lda brtbl,x        ;low order adr byte
000135r 2  48           	pha                 ;onto stack for non-reg op
000136r 2  A5 rr        	lda r14h           ;"prior result reg" index
000138r 2  4A           	lsr                 ;prepare carry for bc, bnc.
000139r 2  60           	rts                 ;goto non-reg op routine
00013Ar 2               rtnz:
00013Ar 2  68           	pla                 ;pop return address
00013Br 2  68           	pla
00013Cr 2  20 rr rr     	jsr restore        ;restore 6502 reg contents
00013Fr 2  6C rr rr     	jmp (r15l)         ;return to 6502 code via pc
000142r 2               setz:
000142r 2  B1 rr        	lda (r15l),y       ;high order byte of constant
000144r 2  95 rr        	sta r0h,x
000146r 2  88           	dey
000147r 2  B1 rr        	lda (r15l),y       ;low order byte of constant
000149r 2  95 rr        	sta r0l,x
00014Br 2  98           	tya                 ;y reg contains 1
00014Cr 2  38           	sec
00014Dr 2  65 rr        	adc r15l           ;add 2 to pc
00014Fr 2  85 rr        	sta r15l
000151r 2  90 02        	bcc set2
000153r 2  E6 rr        	inc r15h
000155r 2               set2:
000155r 2  60           	rts
000156r 2               ;
000156r 2               optbl:
000156r 2  rr           	.byte <(set-1)		;1x
000157r 2               brtbl:
000157r 2  rr           	.byte <(rtn-1)		;0
000158r 2  rr           	.byte <(ld-1)		;2x
000159r 2  rr           	.byte <(br-1)		;1
00015Ar 2  rr           	.byte <(st-1)		;3x
00015Br 2  rr           	.byte <(bnc-1)		;2
00015Cr 2  rr           	.byte <(ldat-1)		;4x
00015Dr 2  rr           	.byte <(bc-1)		;3
00015Er 2  rr           	.byte <(stat-1)		;5x
00015Fr 2  rr           	.byte <(bp-1)		;4
000160r 2  rr           	.byte <(lddat-1)	;6x
000161r 2  rr           	.byte <(bm-1)		;5
000162r 2  rr           	.byte <(stdat-1)	;7x
000163r 2  rr           	.byte <(bz-1)		;6
000164r 2  rr           	.byte <(pop-1)		;8x
000165r 2  rr           	.byte <(bnz-1)		;7
000166r 2  rr           	.byte <(stpat-1)	;9x
000167r 2  rr           	.byte <(bm1-1)		;8
000168r 2  rr           	.byte <(addi-1)		;ax
000169r 2  rr           	.byte <(bnm1-1)		;9
00016Ar 2  rr           	.byte <(sub-1)		;bx
00016Br 2  rr           	.byte <(bk-1)		;a
00016Cr 2  rr           	.byte <(popd-1)		;cx
00016Dr 2  rr           	.byte <(rs-1)		;b
00016Er 2  rr           	.byte <(cpr-1)		;dx
00016Fr 2  rr           	.byte <(bs-1)		;c
000170r 2  rr           	.byte <(inr-1)		;ex
000171r 2  rr           	.byte <(nul-1)		;d
000172r 2  rr           	.byte <(dcr-1)		;fx
000173r 2  rr           	.byte <(nul-1)		;e
000174r 2  rr           	.byte <(nul-1)		;unused
000175r 2  rr           	.byte <(nul-1)		;f
000176r 2               ;
000176r 2               save:
000176r 2  8D rr rr     	sta savea
000179r 2  8E rr rr     	stx savex
00017Cr 2  8C rr rr     	sty savey
00017Fr 2  08           	php
000180r 2  68           	pla
000181r 2  8D rr rr     	sta saves
000184r 2  D8           	cld
000185r 2  60           	rts
000186r 2               ;
000186r 2               restore:
000186r 2  AD rr rr     	lda saves
000189r 2  48           	pha
00018Ar 2  AD rr rr     	lda savea
00018Dr 2  AE rr rr     	ldx savex
000190r 2  AC rr rr     	ldy savey
000193r 2  28           	plp
000194r 2  60           	rts
000195r 2               ;
000195r 2               
000195r 1               sweet_end:
000195r 1               sweet_len	:= sweet_end-sweet_start
000195r 1               ;
000195r 1               	.include "interrupt.a65"
000195r 2               ;-----------------------------------------------------------------------------
000195r 2               ; fsm65 fs monitor for 6502
000195r 2               ; Fabio Sturman (c) 2019,20,21,22
000195r 2               ; fabio.sturman@gmail.com
000195r 2               ;-----------------------------------------------------------------------------
000195r 2               ; a65 - 6502 assembler file
000195r 2               ; i65 - 6502 include file
000195r 2               ; assembled using cc65 suite
000195r 2               ; assembler: ca65
000195r 2               ; linker: ld65
000195r 2               ;-----------------------------------------------------------------------------
000195r 2               ; interrupt.a65
000195r 2               ;-----------------------------------------------------------------------------
000195r 2               ; Interrupt handlers
000195r 2               ;-----------------------------------------------------------------------------
000195r 2               ;
000195r 2               ; nmi_handler
000195r 2               ;
000195r 2  48           nmi_handler:    pha
000196r 2  DA                           phx
000197r 2  5A                           phy
000198r 2  6C rr rr                     jmp (nmi_vec)
00019Br 2               ;
00019Br 2               ;--------------------------------------------------------------------
00019Br 2               ;
00019Br 2               ; irq_handler
00019Br 2               ;
00019Br 2  48           irq_handler:    pha
00019Cr 2  DA                           phx
00019Dr 2  5A                           phy
00019Er 2  BA                           tsx               ;test if brk
00019Fr 2  BD 04 01                     lda $104,x
0001A2r 2  29 10                        and #$10           ; break bit
0001A4r 2  D0 03                        bne brk_handler   ;irq_handler0
0001A6r 2  6C rr rr                     jmp (irq_vec)     ;handle irq
0001A9r 2               ;
0001A9r 2               ;--------------------------------------------------------------------
0001A9r 2               ;
0001A9r 2               ; brk handling
0001A9r 2               ;
0001A9r 2  68           brk_handler:    pla
0001AAr 2  8D rr rr                     sta reg_y
0001ADr 2  68                           pla
0001AEr 2  8D rr rr                     sta reg_x
0001B1r 2  68                           pla
0001B2r 2  8D rr rr                     sta reg_a
0001B5r 2  68                           pla
0001B6r 2  8D rr rr                     sta reg_cc
0001B9r 2  68                           pla
0001BAr 2  8D rr rr                     sta reg_pc
0001BDr 2  68                           pla
0001BEr 2  8D rr rr                     sta reg_pc+1
0001C1r 2  BA                           tsx
0001C2r 2  8E rr rr                     stx reg_sp
0001C5r 2  CE rr rr                     dec reg_pc
0001C8r 2  D0 03                        bne brk_handler1
0001CAr 2  CE rr rr                     dec reg_pc+1
0001CDr 2  6C rr rr     brk_handler1:   jmp (brk_vec)
0001D0r 2               ;
0001D0r 2               ;--------------------------------------------------------------------
0001D0r 2               ;
0001D0r 2               ; int_exit last step of int
0001D0r 2               ;
0001D0r 2  7A           int_exit:       ply
0001D1r 2  FA                           plx
0001D2r 2  68                           pla
0001D3r 2  40                           rti
0001D4r 2               ;
0001D4r 2  20 rr rr     brk_exe:        jsr cmd_print_regs
0001D7r 2  4C rr rr                     jmp warm
0001DAr 2               ;
0001DAr 2               ;--------------------------------------------------------------------
0001DAr 2               ;
0001DAr 2               ; run_taget - return to program which executed a brk
0001DAr 2               ;           - jump command
0001DAr 2               ;
0001DAr 2  AE rr rr     run_target:     ldx reg_sp                  ;back to user stack
0001DDr 2  9A                           txs
0001DEr 2  AD rr rr                     lda reg_pc+1                ;save ms user pc for rti
0001E1r 2  48                           pha
0001E2r 2  AD rr rr                     lda reg_pc                  ;save ls user pc for rti
0001E5r 2  48                           pha
0001E6r 2  AD rr rr                     lda reg_cc                  ;save user condition codes for rti
0001E9r 2  48                           pha
0001EAr 2  AE rr rr                     ldx reg_x
0001EDr 2  AC rr rr                     ldy reg_y
0001F0r 2  AD rr rr                     lda reg_a
0001F3r 2  40                           rti
0001F4r 2               ;
0001F4r 2               
0001F4r 2               
0001F4r 1               	.include "acia.a65"
0001F4r 2               ;
0001F4r 2               ;----------------------------------------------------------
0001F4r 2               ; m65 - fs65sbc simple monitor
0001F4r 2               ;----------------------------------------------------------
0001F4r 2               ; acia.a65 - acia and soft acia related routines
0001F4r 2               ; by Fabio Sturman (c) 2019,2023
0001F4r 2               ; fabio.sturman@gmail.com
0001F4r 2               ;----------------------------------------------------------
0001F4r 2               ;
0001F4r 2               ;CRYSTAL         = 36864
0001F4r 2               CRYSTAL         = 18432
0001F4r 2               ;
0001F4r 2               .if CRYSTAL = 18432
0001F4r 2               ; crystal 1.8432 MHz
0001F4r 2               BAUD_4800       = $c
0001F4r 2               BAUD_7200       = $d
0001F4r 2               BAUD_9600       = $e
0001F4r 2               BAUD_19200      = $f
0001F4r 2               BAUD_115200     = $0
0001F4r 2               ;
0001F4r 2               ; BAUD is passed from command line
0001F4r 2               ;
0001F4r 2               .if BAUD = 115200
0001F4r 2                   ACIA_BAUD = BAUD_115200
0001F4r 2               .elseif BAUD = 19200
0001F4r 2                   ACIA_BAUD = BAUD_19200
0001F4r 2               .elseif BAUD = 9600
0001F4r 2                   ACIA_BAUD = BAUD_9600
0001F4r 2               .elseif BAUD = 7200
0001F4r 2                   ACIA_BAUD = BAUD_7200
0001F4r 2               .elseif BAUD = 4800
0001F4r 2                  ACIA_BAUD = BAUD_4800
0001F4r 2               .else
0001F4r 2                  ACIA_BAUD = BAUD_4800
0001F4r 2               .endif
0001F4r 2               .endif
0001F4r 2               ;
0001F4r 2               .if CRYSTAL = 36864
0001F4r 2               ; crystal 3.6864 MHz
0001F4r 2               BAUD_9600       = $c
0001F4r 2               BAUD_14400      = $d
0001F4r 2               BAUD_19200      = $e
0001F4r 2               BAUD_38400      = $f
0001F4r 2               BAUD_230400     = $0
0001F4r 2               ;
0001F4r 2               ; BAUD is passed from command line
0001F4r 2               ;
0001F4r 2               .if BAUD = 230400
0001F4r 2                   ACIA_BAUD = BAUD_230400
0001F4r 2               .elseif BAUD = 38400
0001F4r 2                   ACIA_BAUD = BAUD_38400
0001F4r 2               .elseif BAUD = 19200
0001F4r 2                   ACIA_BAUD = BAUD_19200
0001F4r 2               .elseif BAUD = 14400
0001F4r 2                   ACIA_BAUD = BAUD_14400
0001F4r 2               .elseif BAUD = 9600
0001F4r 2                   ACIA_BAUD = BAUD_9600
0001F4r 2               .else
0001F4r 2                  ACIA_BAUD = BAUD_9600
0001F4r 2               .endif
0001F4r 2               .endif
0001F4r 2               ;
0001F4r 2               ;---------------------------------------------------------------------
0001F4r 2               ; acia_init - acia initialization
0001F4r 2               ; in:  none
0001F4r 2               ; out: none
0001F4r 2               ;---------------------------------------------------------------------
0001F4r 2               ;
0001F4r 2               ; interrupt driven
0001F4r 2               ;
0001F4r 2               acia_init:
0001F4r 2  9C rr rr     	stz rx_cnt
0001F7r 2  9C rr rr     	stz rx_tail
0001FAr 2  9C rr rr     	stz rx_head
0001FDr 2  9C rr rr     	stz tx_head
000200r 2  9C rr rr     	stz tx_tail
000203r 2  9C rr rr     	stz tx_cnt
000206r 2  9C 01 E0     	stz acia_reset
000209r 2               ;
000209r 2               	;lda #ACIA_BAUD+$10
000209r 2  A9 1F        	lda #$1f
00020Br 2  8D 03 E0     	sta acia_control
00020Er 2               ;
00020Er 2  A9 09        	lda #$09	; No parity, no rx echo, rts true, rx irq, tx no irq
000210r 2  8D 02 E0     	sta acia_command
000213r 2  20 rr rr     	jsr cts_init
000216r 2  4C rr rr     	jmp rts_init
000219r 2               ;
000219r 2               ;---------------------------------------------------------------------
000219r 2               ; get_c - read char vectored through getc_vec
000219r 2               ; in:     do not care
000219r 2               ; out:    valid char in A if C=1 else no char
000219r 2               ;---------------------------------------------------------------------
000219r 2               ;
000219r 2               mconr:
000219r 2               get_c:
000219r 2  6C rr rr     	jmp (getc_vec)
00021Cr 2               ;
00021Cr 2               ; inkey test if data avail
00021Cr 2               ;
00021Cr 2               mcont:
00021Cr 2               get_c_con_test:
00021Cr 2  38           	sec
00021Dr 2  AD rr rr     	lda rx_cnt
000220r 2  D0 01        	bne @q
000222r 2  18           	clc
000223r 2               @q:
000223r 2  60           	rts
000224r 2               ;
000224r 2               ;---------------------------------------------------------------------
000224r 2               ; get_c_con - read char from serial port buffer
000224r 2               ; in:   do not care
000224r 2               ; out:  A = data Byte
000224r 2               ;       C = 0 no data in A
000224r 2               ;       C = 1 data in A
000224r 2               ; tests also if enough space in buffer to reenable
000224r 2               ; remote transmitter
000224r 2               ;---------------------------------------------------------------------
000224r 2               ;
000224r 2               ; interrupt mode
000224r 2               ;
000224r 2               get_c_con:
000224r 2  5A           	phy
000225r 2  AD rr rr     	lda rx_cnt
000228r 2  F0 19        	beq @1
00022Ar 2  C9 70        	cmp #$70		; test if buffer less than 87%
00022Cr 2  B0 03        	bcs @0
00022Er 2  20 rr rr     	jsr rts_0		; if yes reenable tx data from sender (RTS<-0)
000231r 2               @0:
000231r 2  AD rr rr     	lda rx_head
000234r 2  29 7F        	and #$7f
000236r 2  A8           	tay
000237r 2  B9 rr rr     	lda rx_buf,y
00023Ar 2  EE rr rr     	inc rx_head
00023Dr 2  CE rr rr     	dec rx_cnt
000240r 2  38           	sec
000241r 2  80 01        	bra @2
000243r 2               @1:
000243r 2  18           	clc
000244r 2               @2:
000244r 2  7A           	ply
000245r 2  60           	rts
000246r 2               ;
000246r 2               ; get_c_blk - blocking receiving routine
000246r 2               ;
000246r 2               get_c_blk:
000246r 2  20 rr rr     	jsr get_c_con
000249r 2  90 FB        	bcc get_c_blk
00024Br 2  60           	rts
00024Cr 2               ;
00024Cr 2               ;---------------------------------------------------------------------
00024Cr 2               ; put_c - put character vectored through putc_vc
00024Cr 2               ; in:    A=data to transmitt
00024Cr 2               ; out:   C=0
00024Cr 2               ;---------------------------------------------------------------------
00024Cr 2               ;
00024Cr 2               mconw:
00024Cr 2               put_c:
00024Cr 2  6C rr rr     	jmp (putc_vec)
00024Fr 2               ;
00024Fr 2               ;---------------------------------------------------------------------
00024Fr 2               ; put_c_con - prints to serial port
00024Fr 2               ; test  for cts
00024Fr 2               ; no wait if buffer is full.
00024Fr 2               ; use: none
00024Fr 2               ; in:  A = data
00024Fr 2               ; out: A = data
00024Fr 2               ; C=0 no room or tx disabled by receiver via ctsd
00024Fr 2               ; C=1 ok
00024Fr 2               ;---------------------------------------------------------------------
00024Fr 2               ;
00024Fr 2               ; interrupt mode
00024Fr 2               ;
00024Fr 2               put_c_con:
00024Fr 2  5A           	phy
000250r 2  48           	pha
000251r 2  20 rr rr     	jsr cts		; test cts
000254r 2  D0 20        	bne @q		; if 1 exit with c=0
000256r 2  AC rr rr     	ldy tx_cnt
000259r 2  30 1B        	bmi @q		; if no room  exit c=0
00025Br 2  68           	pla
00025Cr 2  48           	pha
00025Dr 2  48           	pha
00025Er 2  AD rr rr     	lda tx_tail
000261r 2  29 7F        	and #$7f
000263r 2  A8           	tay
000264r 2  68           	pla
000265r 2  99 rr rr     	sta tx_buf,y
000268r 2  EE rr rr     	inc tx_tail
00026Br 2  EE rr rr     	inc tx_cnt
00026Er 2  A0 05        	ldy #$05
000270r 2  8C 02 E0     	sty acia_command	; turn on tx int
000273r 2  38           	sec					; exit with c=1
000274r 2  80 01        	bra @e
000276r 2               @q:
000276r 2  18           	clc
000277r 2               @e:
000277r 2  68           	pla
000278r 2  7A           	ply
000279r 2  60           	rts
00027Ar 2               ;
00027Ar 2               put_c_blk:
00027Ar 2  20 rr rr     	jsr put_c_con
00027Dr 2  90 FB        	bcc put_c_blk
00027Fr 2  60           	rts
000280r 2               ;
000280r 2               ;---------------------------------------------------------------------
000280r 2               ; acia_int - interrupt service routine
000280r 2               ; reads char fron acia and stores in rx_buf
000280r 2               ; tests space in buffer and if low disables
000280r 2               ; transmitter
000280r 2               ;---------------------------------------------------------------------
000280r 2               ;
000280r 2               acia_int:
000280r 2  AD 01 E0     	lda acia_status
000283r 2  10 5C        	bpl @q			;no acia int
000285r 2  89 08        	bit #%00001000	;test if rx int
000287r 2  D0 06        	bne @rx			;is rx int
000289r 2  89 10        	bit #%00010000	;test if tx int
00028Br 2  D0 31        	bne @tx			;is tx int
00028Dr 2  80 52        	bra @q			;exit int
00028Fr 2               @rx:
00028Fr 2  89 02        	bit #%00000010	;test for framing error
000291r 2  F0 08        	beq @nb			;rxdf+frer=break
000293r 2  AD 00 E0     	lda acia_data	;clear int flags
000296r 2  EE rr rr     	inc breakf
000299r 2  80 1C        	bra @c
00029Br 2               @nb:
00029Br 2  AD rr rr     	lda rx_tail		; tx tail uses only 7 bits
00029Er 2  29 7F        	and #$7f
0002A0r 2  A8           	tay
0002A1r 2  AD 00 E0     	lda acia_data
0002A4r 2  99 rr rr     	sta rx_buf,y
0002A7r 2  EE rr rr     	inc rx_tail
0002AAr 2  EE rr rr     	inc rx_cnt		; test if rx fuffer @ 90%
0002ADr 2  AD rr rr     	lda rx_cnt
0002B0r 2  C9 75        	cmp #$75
0002B2r 2  90 03        	bcc @c			; if less continue
0002B4r 2  20 rr rr     	jsr rts_1		; rts<-false
0002B7r 2               @c:
0002B7r 2  AD 01 E0     	lda acia_status	; test if tx int
0002BAr 2  29 10        	and #%00010000
0002BCr 2  F0 23        	beq @q			; if not exit
0002BEr 2               @tx:
0002BEr 2  20 rr rr     	jsr cts
0002C1r 2  D0 19        	bne @txo
0002C3r 2  AD rr rr     	lda tx_cnt		; any characters to xmit?
0002C6r 2  F0 14        	beq @txo		; no, turn off xmit
0002C8r 2  AD rr rr     	lda tx_head		; tx_head uses only 7 bits
0002CBr 2  29 7F        	and #$7f
0002CDr 2  A8           	tay
0002CEr 2  B9 rr rr     	lda tx_buf,y	; next ch from tx buf
0002D1r 2  8D 00 E0     	sta acia_data	; send the data
0002D4r 2  EE rr rr     	inc tx_head
0002D7r 2  CE rr rr     	dec tx_cnt		; decrement counter
0002DAr 2  80 05        	bra @q			; if not zero, exit
0002DCr 2               @txo:
0002DCr 2  A0 09        	ldy #$09            ;get mask for xmit off / rcv on (2)
0002DEr 2  8C 02 E0     	sty acia_command    ;turn off xmit irq bits (5)
0002E1r 2               @q:
0002E1r 2  4C rr rr     	jmp int_exit
0002E4r 2               ;
0002E4r 2               ; acia0 rts(out)=PB2
0002E4r 2               ;
0002E4r 2               RTS_DDR		= ddrb0
0002E4r 2               RTS_PORT	= portb0
0002E4r 2               RTS_MASK	= $04
0002E4r 2               ;
0002E4r 2               rts_init:
0002E4r 2  AD 02 E1     	lda RTS_DDR
0002E7r 2  09 04        	ora #RTS_MASK
0002E9r 2  8D 02 E1     	sta RTS_DDR
0002ECr 2               ;
0002ECr 2               rts_0:
0002ECr 2  AD 00 E1     	lda RTS_PORT
0002EFr 2  29 FB        	and #<~RTS_MASK
0002F1r 2  8D 00 E1     	sta RTS_PORT
0002F4r 2  60           	rts
0002F5r 2               ;
0002F5r 2               rts_1:
0002F5r 2  AD 00 E1     	lda RTS_PORT
0002F8r 2  09 04        	ora #RTS_MASK
0002FAr 2  8D 00 E1     	sta RTS_PORT
0002FDr 2  60           	rts
0002FEr 2               ;
0002FEr 2               ; acia0 cts(in)=PB4
0002FEr 2               ;
0002FEr 2               CTS_DDR		= ddrb0
0002FEr 2               CTS_PORT	= portb0
0002FEr 2               CTS_MASK	= $10
0002FEr 2               ;
0002FEr 2               cts_init:
0002FEr 2  AD 02 E1     	lda CTS_DDR
000301r 2  29 EF        	and #<~CTS_MASK
000303r 2  8D 02 E1     	sta CTS_DDR
000306r 2  60           	rts
000307r 2               ;
000307r 2               cts:
000307r 2  AD 00 E1     	lda CTS_PORT
00030Ar 2  29 10        	and #CTS_MASK
00030Cr 2  60           	rts
00030Dr 2               ;
00030Dr 2               ;---------------------------------------------------------------------
00030Dr 2               ; acia1_init - soft acia on VIA0 pb0,1
00030Dr 2               ; 1200,8,n,1
00030Dr 2               ;---------------------------------------------------------------------
00030Dr 2               ;
00030Dr 2               ACIA1_TX_MASK	= 1
00030Dr 2               ACIA1_CTS_MASK	= 2
00030Dr 2               ACIA1_PORT		= portb0
00030Dr 2               ACIA1_DDR		= ddrb0
00030Dr 2               ACIA1_DELAY		= 233	;1200
00030Dr 2               ;
00030Dr 2               ; INIT ACIA1
00030Dr 2               ; use: a
00030Dr 2               ; in:  none
00030Dr 2               ; out: none
00030Dr 2               ;
00030Dr 2               ; pb0=tx
00030Dr 2               ; pb1=cts
00030Dr 2               ;
00030Dr 2               acia1_init:
00030Dr 2  AD 02 E1     	lda ACIA1_DDR
000310r 2  29 FD        	and #<~ACIA1_CTS_MASK	;cts in
000312r 2  09 01        	ora #ACIA1_TX_MASK		;tx out
000314r 2  8D 02 E1     	sta ACIA1_DDR
000317r 2               ;
000317r 2  AD 00 E1     	lda ACIA1_PORT			;tx<-1
00031Ar 2  09 01        	ora #ACIA1_TX_MASK
00031Cr 2  8D 00 E1     	sta ACIA1_PORT
00031Fr 2  60           	rts
000320r 2               ;
000320r 2               ; acia1_cts - test if ACIA1 READY TO TX
000320r 2               ; use: a
000320r 2               ; in: none
000320r 2               ; out: z=1 on ready
000320r 2               ;
000320r 2               mlstt:
000320r 2               acia1_cts:
000320r 2  AD 00 E1     	lda ACIA1_PORT
000323r 2  29 02        	and #ACIA1_CTS_MASK
000325r 2  60           	rts
000326r 2               ;
000326r 2               ; acia1_put_c - tx CHAR ON ACIA1
000326r 2               ; use: none
000326r 2               ; in:  a=char
000326r 2               ; out: none
000326r 2               ;
000326r 2               mlstw:
000326r 2               acia1_put_c:
000326r 2  8D rr rr     	sta dout
000329r 2  48           	pha
00032Ar 2  DA           	phx
00032Br 2  5A           	phy
00032Cr 2  A2 08        	ldx #8		; bit counter
00032Er 2               ;
00032Er 2  AD 00 E1     	lda ACIA1_PORT			; start bit
000331r 2  29 FE        	and #<~ACIA1_TX_MASK
000333r 2  8D 00 E1     	sta ACIA1_PORT
000336r 2  20 rr rr     	jsr acia1_bit_dly
000339r 2               @0:
000339r 2  AD 00 E1     	lda ACIA1_PORT
00033Cr 2  29 FE        	and #<~ACIA1_TX_MASK	;tx bit<-0
00033Er 2  6E rr rr     	ror dout
000341r 2  90 02        	bcc @1
000343r 2  09 01        	ora #ACIA1_TX_MASK	;tx bit<-1
000345r 2               @1:
000345r 2  8D 00 E1     	sta ACIA1_PORT
000348r 2  20 rr rr     	jsr acia1_bit_dly
00034Br 2  CA           	dex
00034Cr 2  D0 EB        	bne @0
00034Er 2               ;
00034Er 2  AD 00 E1     	lda ACIA1_PORT			; stop bit
000351r 2  09 01        	ora #ACIA1_TX_MASK
000353r 2  8D 00 E1     	sta ACIA1_PORT
000356r 2  20 rr rr     	jsr acia1_bit_dly
000359r 2               ;
000359r 2  7A           	ply
00035Ar 2  FA           	plx
00035Br 2  68           	pla
00035Cr 2  60           	rts
00035Dr 2               ;
00035Dr 2               ; DELAY FOR 1 BIT
00035Dr 2               ;
00035Dr 2               acia1_bit_dly:
00035Dr 2  A0 E9        	ldy #ACIA1_DELAY
00035Fr 2               @l:
00035Fr 2  88           	dey
000360r 2  EA           	nop
000361r 2  D0 FC        	bne @l
000363r 2  60           	rts
000364r 2               ;
000364r 2               
000364r 1               	.include "timers.a65"
000364r 2               ;
000364r 2               ;----------------------------------------------------------
000364r 2               ; fsm65 -fs65sbc simple monitor
000364r 2               ;----------------------------------------------------------
000364r 2               ; timers.a65 - acia related routines
000364r 2               ; by Fabio Sturman
000364r 2               ; fabio.sturman@gmail.com
000364r 2               ;----------------------------------------------------------
000364r 2               ; via0
000364r 2               ; timer1 system timer
000364r 2               ; acr<= %01xx-xxxx for t1 continuos interrupt
000364r 2               ; load t1cl<= <40000 t1ch<= >40000
000364r 2               ; ier<=%x1xx-xxxx
000364r 2               ; 4xsoft timer 8 bit ~5.12s
000364r 2               ; 1xsoft timer 32 bit ~ 994 d
000364r 2               ;
000364r 2               ; sr mode4 freerunning timer2l
000364r 2               ; pcr<= %xx0x-xxxx t2cl<= 250 t2ch<=0
000364r 2               ; buzzer on cb2 or cb1. T(squarewave on cb1)=2*(n+2)
000364r 2               ; sr stop   acr<=xxx0-00xx
000364r 2               ; sr start  acr<=xxx1-00xx
000364r 2               ;
000364r 2               TIMER_SLICE     = 39986 ;19993 ;39986 ;40000
000364r 2               BUZZER_TIME_ON  = 5 ;80-100ms
000364r 2               ;
000364r 2               	;.define TIMER8_DEF
000364r 2               ;
000364r 2               buzzer_init:
000364r 2  A9 7C        	lda #124 ; ;150 ;200 ;250
000366r 2  8D 08 E1     	sta t2cl0
000369r 2  A9 00        	lda #0
00036Br 2  8D 09 E1     	sta t2ch0
00036Er 2  AD 0C E1     	lda pcr0
000371r 2  29 DF        	and #%11011111
000373r 2  8D 0C E1     	sta pcr0
000376r 2               ;
000376r 2               beep:
000376r 2  2C rr rr     	bit fsmflags
000379r 2  10 14        	bpl buzzer_start0
00037Br 2               mbuz:
00037Br 2               buzzer_on:
00037Br 2  A9 05        	lda #BUZZER_TIME_ON
00037Dr 2  8D rr rr     	sta timer8_4
000380r 2               ;
000380r 2               buzzer_start:
000380r 2  AD 0B E1     	lda acr0
000383r 2  29 E3        	and #%11100011
000385r 2  09 10        	ora #%00010000
000387r 2  8D 0B E1     	sta acr0
00038Ar 2  A9 0F        	lda #$0f ;0f ;33
00038Cr 2  8D 0A E1     	sta sr0
00038Fr 2               buzzer_start0:
00038Fr 2  60           	rts
000390r 2               ;
000390r 2               timers_init:
000390r 2  A9 32        	lda #<TIMER_SLICE
000392r 2  8D 04 E1     	sta t1cl0
000395r 2  A9 9C        	lda #>TIMER_SLICE
000397r 2  8D 05 E1     	sta t1ch0
00039Ar 2  AD 0B E1     	lda acr0
00039Dr 2  29 3F        	and #%00111111
00039Fr 2  09 40        	ora #%01000000
0003A1r 2  8D 0B E1     	sta acr0
0003A4r 2  A9 00        	lda #0
0003A6r 2  8D rr rr     	sta sys_timer
0003A9r 2  8D rr rr     	sta sys_timer+1
0003ACr 2  8D rr rr     	sta sys_timer+2
0003AFr 2  8D rr rr     	sta sys_timer+3
0003B2r 2  8D rr rr     	sta timer8_4
0003B5r 2               	.ifdef TIMER8_DEF
0003B5r 2               	sta timer8_0
0003B5r 2               	sta timer8_1
0003B5r 2               	sta timer8_2
0003B5r 2               	sta timer8_3
0003B5r 2               	mov_n2x rtsp, timer8_0_vec  ; init timer vector to rts
0003B5r 2               	mov_n2x rtsp, timer8_1_vec
0003B5r 2               	mov_n2x rtsp, timer8_2_vec
0003B5r 2               	mov_n2x rtsp, timer8_3_vec
0003B5r 2               	.endif
0003B5r 2  A9 C0        	lda #%11000000  ; enable only int from t1
0003B7r 2  8D 0E E1     	sta ier0
0003BAr 2  A9 3F        	lda #%00111111
0003BCr 2  8D 0E E1     	sta ier0
0003BFr 2  60           	rts
0003C0r 2               ;
0003C0r 2               	.ifdef TIMER8_DEF
0003C0r 2               ;
0003C0r 2               ; a=timer val  x=timer index 0..3
0003C0r 2               ;
0003C0r 2               timer8_start:
0003C0r 2               	pha
0003C0r 2               	txa
0003C0r 2               	and #3
0003C0r 2               	tax
0003C0r 2               	pla
0003C0r 2               	sta timer8_0,x
0003C0r 2               	rts
0003C0r 2               ;
0003C0r 2               timer8_vec:
0003C0r 2               	txa
0003C0r 2               	asl a
0003C0r 2               	tax
0003C0r 2               	jmp (timer8_0_vec,x)
0003C0r 2               	.endif
0003C0r 2               ;
0003C0r 2               ; reads system timer
0003C0r 2               ; out: xa: points to buf
0003C0r 2               ;
0003C0r 2               mtimr:
0003C0r 2               sys_timer_get:
0003C0r 2  78           	sei
0003C1r 2  AD 05 E1     	lda t1ch0
0003C4r 2  8D rr rr     	sta temp+4
0003C7r 2               ;
0003C7r 2  AD rr rr     	lda sys_timer
0003CAr 2  8D rr rr     	sta temp
0003CDr 2  AD rr rr     	lda sys_timer+1
0003D0r 2  8D rr rr     	sta temp+1
0003D3r 2  AD rr rr     	lda sys_timer+2
0003D6r 2  8D rr rr     	sta temp+2
0003D9r 2  AD rr rr     	lda sys_timer+3
0003DCr 2  8D rr rr     	sta temp+3
0003DFr 2  58           	cli
0003E0r 2  A9 rr        	lda #<temp
0003E2r 2  A2 rr        	ldx #>temp
0003E4r 2  60           	rts
0003E5r 2               ;
0003E5r 2               ; command read system timer from cl
0003E5r 2               ;
0003E5r 2               cmd_sys_timer:
0003E5r 2  20 rr rr     	jsr sys_timer_get
0003E8r 2  AD rr rr AC  	mov_x2ay temp+2
0003ECr 2  rr rr        
0003EEr 2  20 rr rr     	jsr put_w_hex
0003F1r 2  AD rr rr AC  	mov_x2ay temp
0003F5r 2  rr rr        
0003F7r 2  20 rr rr     	jsr put_w_hex
0003FAr 2  4C rr rr     	jmp no_er
0003FDr 2               ;
0003FDr 2               ; via0 interrupt service routine
0003FDr 2               ;
0003FDr 2               ; timer8_4  buzzer timer
0003FDr 2               ;
0003FDr 2               via_int:
0003FDr 2  AD 0D E1     	lda ifr0
000400r 2  10 31        	bpl @q
000402r 2  AD 04 E1     	lda t1cl0
000405r 2               ;
000405r 2  20 rr rr     	jsr cts				; test for cts=0
000408r 2  D0 05        	bne @s
00040Ar 2  A9 05        	lda #$05			; if cts=0 turn tx irq on
00040Cr 2  8D 02 E0     	sta acia_command
00040Fr 2               @s:
00040Fr 2  AD rr rr     	lda timer8_4		; buzzer
000412r 2  F0 0D        	beq @a
000414r 2  CE rr rr     	dec timer8_4
000417r 2  D0 08        	bne @a
000419r 2  AD 0B E1     	lda acr0			; buzzer off
00041Cr 2  29 E3        	and #%11100011
00041Er 2  8D 0B E1     	sta acr0
000421r 2               ;
000421r 2               @a:
000421r 2               	.ifdef TIMER8_DEF
000421r 2               	ldx #3				; decrement timers if !=0
000421r 2               @0:
000421r 2               	lda timer8_0,x
000421r 2               	beq @1
000421r 2               	dec timer8_0,x
000421r 2               	bne @1
000421r 2               	phx
000421r 2               	jsr timer8_vec		; if timer==0 jmp to timeout routine
000421r 2               	plx
000421r 2               @1:
000421r 2               	dex
000421r 2               	bpl @0
000421r 2               	.endif
000421r 2               @m:
000421r 2  EE rr rr     	inc sys_timer
000424r 2  D0 0D        	bne @q
000426r 2  EE rr rr     	inc sys_timer+1
000429r 2  D0 08        	bne @q
00042Br 2  EE rr rr     	inc sys_timer+2
00042Er 2  D0 03        	bne @q
000430r 2  EE rr rr     	inc sys_timer+3
000433r 2               @q:
000433r 2  4C rr rr     	jmp acia_int
000436r 2               ;
000436r 2               
000436r 2               
000436r 1               	.include "get_put.a65"
000436r 2               ;
000436r 2               ;----------------------------------------------------------
000436r 2               ; get_s - reads tring into cmd_buf max 80 chars
000436r 2               ; and prints cr lf
000436r 2               ; returns
000436r 2               ;   c=0 for CR - ay pointer to text buffer - input data terminated by 0
000436r 2               ;   c=1 for ^X (abort input)
000436r 2               ;----------------------------------------------------------
000436r 2               ;
000436r 2               mgets:
000436r 2               get_s:
000436r 2  A2 50        	ldx #CMD_BUF_LEN-1
000438r 2  A0 00        	ldy #0
00043Ar 2               @0:
00043Ar 2  20 rr rr     	jsr get_c	;Get a char
00043Dr 2  90 FB        	bcc @0		;Retry if no data ready
00043Fr 2  C9 0A        	cmp #LF		;ignore LF
000441r 2  F0 F7        	beq @0
000443r 2  C9 0D        	cmp #CR		;if CR return received string
000445r 2  F0 34        	beq @q
000447r 2  C9 18        	cmp #CTRL_X	;abort
000449r 2  F0 3F        	beq @x
00044Br 2  C9 08        	cmp #BS		;erase last char from buf
00044Dr 2  F0 06        	beq @b
00044Fr 2  C9 7F        	cmp #DEL
000451r 2  F0 02        	beq @b
000453r 2  D0 16        	bne @1
000455r 2               @b:
000455r 2  C0 00        	cpy #0
000457r 2  F0 E1        	beq @0
000459r 2  88           	dey
00045Ar 2  A9 08        	lda #BS
00045Cr 2  20 rr rr     	jsr put_c	;erase last char entered
00045Fr 2  A9 20        	lda #' '
000461r 2  20 rr rr     	jsr put_c
000464r 2  A9 08        	lda #BS
000466r 2  20 rr rr     	jsr put_c
000469r 2  80 CF        	bra @0
00046Br 2               @1:
00046Br 2  C9 20        	cmp #' '
00046Dr 2  90 CB        	bcc @0			;skip other control char
00046Fr 2  20 rr rr     	jsr put_c		;echo char
000472r 2  99 rr rr     	sta cmd_buf,y	;Save byte in buffer
000475r 2  C8           	iny				;Increment offset
000476r 2  CA           	dex				;Test for end of buffer
000477r 2  D0 C1        	bne @0			;Continue if buffer not full
000479r 2  F0 0F        	beq @x			;if buffer full abort
00047Br 2               @q:
00047Br 2  A9 00        	lda #0			;Add terminating zero
00047Dr 2  99 rr rr     	sta cmd_buf,y
000480r 2  20 rr rr     	jsr put_cr_lf
000483r 2  A9 rr        	lda #<cmd_buf
000485r 2  A0 rr        	ldy #>cmd_buf
000487r 2  18           	clc
000488r 2  80 04        	bra @z
00048Ar 2               @x:
00048Ar 2  20 rr rr     	jsr put_cr_lf
00048Dr 2  38           	sec
00048Er 2               @z:
00048Er 2  60           	rts
00048Fr 2               ;
00048Fr 2               ;----------------------------------------------------------
00048Fr 2               ; put_s - print string in ay
00048Fr 2               ; in:  ay pointer to nul terminated string
00048Fr 2               ; out: c=0
00048Fr 2               ;----------------------------------------------------------
00048Fr 2               ;
00048Fr 2               mputs:
00048Fr 2               put_s:
00048Fr 2  85 rr        	sta po
000491r 2  84 rr        	sty po+1
000493r 2               @0:
000493r 2  B2 rr        	lda (po)
000495r 2  F0 0A        	beq @q
000497r 2  20 rr rr     	jsr put_c
00049Ar 2  A2 rr 20 rr  	inc_x po
00049Er 2  rr           
00049Fr 2  80 F2        	bra @0
0004A1r 2               @q:
0004A1r 2  18           	clc
0004A2r 2  60           	rts
0004A3r 2               ;
0004A3r 2               ;----------------------------------------------------------
0004A3r 2               ; put_w_hex - print word hex in ya ()hl)
0004A3r 2               ;----------------------------------------------------------
0004A3r 2               ;
0004A3r 2               mputw:
0004A3r 2               put_w_hex:
0004A3r 2  48           	pha
0004A4r 2  98           	tya
0004A5r 2  20 rr rr     	jsr put_c_hex
0004A8r 2  68           	pla
0004A9r 2  4C rr rr     	jmp put_c_hex
0004ACr 2               ;
0004ACr 2               ;----------------------------------------------------------
0004ACr 2               ; put sp, star, dot, cr-lf;
0004ACr 2               ;----------------------------------------------------------
0004ACr 2               ;
0004ACr 2               mputsp:
0004ACr 2               put_sp:
0004ACr 2  A9 20        	lda #' '
0004AEr 2  4C rr rr     	jmp put_c
0004B1r 2               ;
0004B1r 2               put_star:
0004B1r 2  A9 2A        	lda #'*'
0004B3r 2  4C rr rr     	jmp put_c
0004B6r 2               ;
0004B6r 2               put_dot:
0004B6r 2  A9 2E        	lda #'.'
0004B8r 2  4C rr rr     	jmp put_c
0004BBr 2               ;
0004BBr 2               mputcl:
0004BBr 2               put_cr_lf:
0004BBr 2  48           	pha
0004BCr 2  A9 0D        	lda #CR
0004BEr 2  20 rr rr     	jsr put_c
0004C1r 2  A9 0A        	lda #LF
0004C3r 2  20 rr rr     	jsr put_c
0004C6r 2  68           	pla
0004C7r 2  60           	rts
0004C8r 2               ;
0004C8r 2               ;----------------------------------------------------------
0004C8r 2               ; put_c_hex - print acc hex
0004C8r 2               ; in:  a data to print
0004C8r 2               ; out: none
0004C8r 2               ;----------------------------------------------------------
0004C8r 2               ;
0004C8r 2               mputb:
0004C8r 2               put_c_hex:
0004C8r 2  48           	pha
0004C9r 2  4A           	lsr a
0004CAr 2  4A           	lsr a
0004CBr 2  4A           	lsr a
0004CCr 2  4A           	lsr a
0004CDr 2  20 rr rr     	jsr put_nib_hex
0004D0r 2  68           	pla
0004D1r 2               ;
0004D1r 2               put_nib_hex:
0004D1r 2  29 0F        	and #$0f
0004D3r 2  09 30        	ora #'0'
0004D5r 2  C9 3A        	cmp #'9'+1
0004D7r 2  90 02        	bcc @0
0004D9r 2  69 06        	adc #6
0004DBr 2               @0:
0004DBr 2  4C rr rr     	jmp put_c
0004DEr 2               ;
0004DEr 2               ;----------------------------------------------------------
0004DEr 2               ; put_c_hex + cr + lf
0004DEr 2               ;----------------------------------------------------------
0004DEr 2               ;
0004DEr 2               put_c_hex_cr_lf:
0004DEr 2  20 rr rr     	jsr put_c_hex
0004E1r 2  4C rr rr     	jmp put_cr_lf
0004E4r 2               ;
0004E4r 2               ;----------------------------------------------------------
0004E4r 2               ; get_c_hex  - read hex byte in acc two hex digits from buf
0004E4r 2               ; in:  none
0004E4r 2               ; out: a=data, c=0 ok, c=1 no ok
0004E4r 2               ;----------------------------------------------------------
0004E4r 2               ;
0004E4r 2               get_b_hex:
0004E4r 2               get_c_hex:
0004E4r 2  20 rr rr     	jsr scan
0004E7r 2  F0 1C        	beq @x
0004E9r 2  20 rr rr     	jsr is_hex
0004ECr 2  B0 17        	bcs @x
0004EEr 2  0A           	asl a
0004EFr 2  0A           	asl a
0004F0r 2  0A           	asl a
0004F1r 2  0A           	asl a
0004F2r 2  8D rr rr     	sta count+1
0004F5r 2  20 rr rr     	jsr scan
0004F8r 2  F0 0B        	beq @x
0004FAr 2  20 rr rr     	jsr is_hex
0004FDr 2  B0 06        	bcs @x
0004FFr 2  0D rr rr     	ora count+1
000502r 2  18           	clc
000503r 2  80 01        	bra @q
000505r 2               @x:
000505r 2  38           	sec
000506r 2               @q:
000506r 2  60           	rts
000507r 2               ;
000507r 2               get_b_bcd:
000507r 2  20 rr rr     	jsr get_c_hex
00050Ar 2  AA           	tax
00050Br 2  29 0F        	and #$0f
00050Dr 2  C9 0A        	cmp #10
00050Fr 2  90 0A        	bcc @cc
000511r 2  8A           	txa
000512r 2  29 F0        	and #$f0
000514r 2  C9 A0        	cmp #$a0
000516r 2  90 03        	bcc @cc
000518r 2  38           	sec
000519r 2  80 01        	bra @q
00051Br 2               @cc:
00051Br 2  18           	clc
00051Cr 2               @q:
00051Cr 2  8A           	txa
00051Dr 2  60           	rts
00051Er 2               ;
00051Er 2               ;-----------------------------------------------------------
00051Er 2               ; get_hex - get hex number in ra from buf
00051Er 2               ; stops at first non hex digit
00051Er 2               ;-----------------------------------------------------------
00051Er 2               ;
00051Er 2               get_w_hex:
00051Er 2               get_hex:
00051Er 2  64 rr        	stz ra
000520r 2  64 rr        	stz ra+1
000522r 2  20 rr rr     	jsr scan0
000525r 2               @0:
000525r 2  20 rr rr     	jsr is_hex
000528r 2  B0 19        	bcs @q
00052Ar 2  06 rr        	asl ra    ; reg0 * 16
00052Cr 2  26 rr        	rol ra+1
00052Er 2  06 rr        	asl ra
000530r 2  26 rr        	rol ra+1
000532r 2  06 rr        	asl ra
000534r 2  26 rr        	rol ra+1
000536r 2  06 rr        	asl ra
000538r 2  26 rr        	rol ra+1
00053Ar 2  05 rr        	ora ra
00053Cr 2  85 rr        	sta ra
00053Er 2  20 rr rr     	jsr scan
000541r 2  80 E2        	bra @0
000543r 2               @q:
000543r 2  60           	rts
000544r 2               ;
000544r 2               ;-----------------------------------------------------------
000544r 2               ; is_hex -test if acc valid hex c=0 if ok
000544r 2               ;-----------------------------------------------------------
000544r 2               ;
000544r 2               is_hex:
000544r 2  C9 30        	cmp #'0'
000546r 2  90 16        	bcc @ko
000548r 2  C9 3A        	cmp #':'
00054Ar 2  90 0D        	bcc @ok
00054Cr 2  29 DF        	and #$df		; to upper case
00054Er 2  C9 41        	cmp #'A'
000550r 2  90 0C        	bcc @ko
000552r 2  C9 47        	cmp #'G'
000554r 2  B0 08        	bcs @ko
000556r 2  38           	sec
000557r 2  E9 37        	sbc #('A'-10)
000559r 2               @ok:
000559r 2  29 0F        	and #$0f
00055Br 2  18           	clc
00055Cr 2  80 01            bra @q
00055Er 2               @ko:
00055Er 2  38           	sec
00055Fr 2               @q:
00055Fr 2  60           	rts
000560r 2               ;
000560r 2               ;----------------------------------------------------------
000560r 2               ; scan - increment index & read char from (po)
000560r 2               ;----------------------------------------------------------
000560r 2               ;
000560r 2               scani:
000560r 2  A0 FF        	ldy #$ff		;init scan
000562r 2  8C rr rr     	sty scany
000565r 2               scan:
000565r 2  EE rr rr     	inc scany		;scan next
000568r 2               scan0:
000568r 2  AC rr rr     	ldy scany		;reread
00056Br 2  B9 rr rr     	lda cmd_buf,y
00056Er 2  60           	rts
00056Fr 2               ;
00056Fr 2               mtoupc:
00056Fr 2               toupper:
00056Fr 2  C9 61        	cmp #'a'
000571r 2  90 06        	bcc @ex		;not lower case
000573r 2  C9 7B        	cmp #'{'
000575r 2  B0 02        	bcs @ex		;not lower case
000577r 2  29 DF        	and #$df
000579r 2               @ex:
000579r 2  60           	rts
00057Ar 2               ;
00057Ar 2               ; delayms a=delay 0.5ms
00057Ar 2               ;
00057Ar 2               mdhms:
00057Ar 2               delayhalfms:
00057Ar 2  DA           	phx
00057Br 2  5A           	phy
00057Cr 2  A8           	tay
00057Dr 2               @dl0:
00057Dr 2  A2 C7        	ldx #$c7
00057Fr 2               @dl:
00057Fr 2  CA           	dex
000580r 2  D0 FD        	bne @dl
000582r 2  88           	dey
000583r 2  D0 F8        	bne @dl0
000585r 2  7A           	ply
000586r 2  FA           	plx
000587r 2  60           	rts
000588r 2               ;
000588r 2               
000588r 1               	.include "regs.a65"
000588r 2               ;
000588r 2               ; inc_z
000588r 2               ;
000588r 2               mrinc:
000588r 2  F6 00        inc_zz:         inc 0, x
00058Ar 2  D0 02                        bne inc_z0
00058Cr 2  F6 01                        inc 1, x
00058Er 2  60           inc_z0:         rts
00058Fr 2               ;
00058Fr 2               ; dec_z
00058Fr 2               ;
00058Fr 2               mrdec:
00058Fr 2  B5 00        dec_zz:         lda 0,x
000591r 2  D0 02                        bne dec_z0
000593r 2  D6 01                        dec 1,x
000595r 2  D6 00        dec_z0:         dec 0,x
000597r 2               mrzer:
000597r 2  B5 00        test_zz:        lda 0,x
000599r 2  15 01                        ora 1,x
00059Br 2  60                           rts
00059Cr 2               ;
00059Cr 2               ; add_rb2ra
00059Cr 2               ;
00059Cr 2               mradd:
00059Cr 2  18           add_rb2ra:      clc
00059Dr 2  A5 rr                        lda ra
00059Fr 2  65 rr                        adc rb
0005A1r 2  85 rr                        sta ra
0005A3r 2  A5 rr                        lda ra+1
0005A5r 2  65 rr                        adc rb+1
0005A7r 2  85 rr                        sta ra+1
0005A9r 2  60                           rts
0005AAr 2               ;
0005AAr 2               ; sub_rb2ra
0005AAr 2               ;
0005AAr 2               mrsub:
0005AAr 2  38           sub_rb2ra:      sec
0005ABr 2  A5 rr                        lda ra
0005ADr 2  E5 rr                        sbc rb
0005AFr 2  85 rr                        sta ra
0005B1r 2  A5 rr                        lda ra+1
0005B3r 2  E5 rr                        sbc rb+1
0005B5r 2  85 rr                        sta ra+1
0005B7r 2  60                           rts
0005B8r 2               ;
0005B8r 2               ; cmp_ra2rb ra<rb c=0
0005B8r 2               ;
0005B8r 2               mrcmp:
0005B8r 2  A5 rr        cmp_ra2rb:      lda ra+1
0005BAr 2  C5 rr                        cmp rb+1
0005BCr 2  90 06                        bcc cmp_ra2rbq
0005BEr 2  D0 04                        bne cmp_ra2rbq
0005C0r 2  A5 rr                        lda ra
0005C2r 2  C5 rr                        cmp rb
0005C4r 2  60           cmp_ra2rbq:     rts
0005C5r 2               ;
0005C5r 2               ; equal_ra2rb
0005C5r 2               ;
0005C5r 2               mrequ:
0005C5r 2  A5 rr        equal_ra2rb:    lda ra
0005C7r 2  C5 rr                        cmp rb
0005C9r 2  D0 04                        bne equal_ra2rbq
0005CBr 2  A5 rr                        lda ra+1
0005CDr 2  C5 rr                        cmp rb+1
0005CFr 2  60           equal_ra2rbq:   rts
0005D0r 2               ;
0005D0r 2               mr0:
0005D0r 2               zero_zz:
0005D0r 2  74 00        	stz 0,x
0005D2r 2  95 01        	sta 1,x
0005D4r 2  60           	rts
0005D5r 2               
0005D5r 2               
0005D5r 1               	.include "i2c.a65"
0005D5r 2               ;-----------------------------------------------------------------------------
0005D5r 2               ; fsm65 fs monitor for 6502
0005D5r 2               ; Fabio Sturman (c) 2019,20,21
0005D5r 2               ; fabio.sturman@gmail.com
0005D5r 2               ;-----------------------------------------------------------------------------
0005D5r 2               ; i2c.a65
0005D5r 2               ; i2c module through via0 6522
0005D5r 2               ; SDA=pa7
0005D5r 2               ; SCL=pa6
0005D5r 2               ;-----------------------------------------------------------------------------
0005D5r 2               ;
0005D5r 2               SDA   = (1 << 7)
0005D5r 2               SCL   = (1 << 6)
0005D5r 2               
0005D5r 2               ;
0005D5r 2               mi2cini:
0005D5r 2  20 rr rr     i2c_init:       jsr i2cdh
0005D8r 2  4C rr rr                     jmp i2cch
0005DBr 2               ;
0005DBr 2               ; i2cwb - write byte
0005DBr 2               ;
0005DBr 2               mi2cwrt:
0005DBr 2               i2c_write:
0005DBr 2  48           i2cwb:          pha
0005DCr 2  AD 01 E1                     lda porta0 ;00
0005DFr 2  29 3F                        and #<(~(SDA+SCL))
0005E1r 2  8D 01 E1                     sta porta0
0005E4r 2  68                           pla
0005E5r 2  A2 09                        ldx #9
0005E7r 2               ;
0005E7r 2  CA           i2cwb_loop:     dex
0005E8r 2  F0 17                        beq i2cwb_ack
0005EAr 2  2A                           rol
0005EBr 2  90 0A                        bcc i2cwb_0
0005EDr 2  48                           pha
0005EEr 2  A9 01                        lda #1
0005F0r 2  20 rr rr                     jsr i2csb   ; send bit
0005F3r 2  68                           pla
0005F4r 2  4C rr rr                     jmp i2cwb_loop
0005F7r 2               ;
0005F7r 2  48           i2cwb_0:        pha
0005F8r 2  A9 00                        lda #0
0005FAr 2  20 rr rr                     jsr i2csb
0005FDr 2  68                           pla
0005FEr 2  4C rr rr                     jmp i2cwb_loop
000601r 2               ;
000601r 2               i2cwb_ack:
000601r 2  20 rr rr                     jsr i2cgb  ;get bit
000604r 2  49 01                        eor #1
000606r 2               ;
000606r 2  60           i2cwb_end:      rts     ; 1=ok 0=fail
000607r 2               ;
000607r 2               ; i2csb - send bit
000607r 2               ;
000607r 2  C9 01        i2csb:          cmp #1
000609r 2  F0 06                        beq i2csb_sda1
00060Br 2               ;
00060Br 2  20 rr rr     i2csb_sda0:     jsr i2cdl   ;data low
00060Er 2  4C rr rr                     jmp i2csb_ck
000611r 2               ;
000611r 2  20 rr rr     i2csb_sda1:     jsr i2cdh   ;data high
000614r 2  4C rr rr                     jmp i2csb_ck
000617r 2               ;
000617r 2  20 rr rr     i2csb_ck:       jsr i2cch
00061Ar 2  20 rr rr                     jsr i2ccl
00061Dr 2  4C rr rr                     jmp i2cdl
000620r 2               ;
000620r 2               ; i2crb - read byte
000620r 2               ;
000620r 2               mi2crea:
000620r 2               i2c_read:
000620r 2  AD 01 E1     i2crb:          lda porta0 ;00
000623r 2  29 3F                        and #<(~(SDA+SCL))
000625r 2  8D 01 E1                     sta porta0
000628r 2  A9 00                        lda #0
00062Ar 2  48                           pha
00062Br 2  A2 09                        ldx #9
00062Dr 2               ;
00062Dr 2  CA           i2crb_loop:     dex
00062Er 2  F0 0A                        beq i2crb_end
000630r 2  20 rr rr                     jsr i2cgb       ; get bit
000633r 2  6A                           ror
000634r 2  68                           pla
000635r 2  2A                           rol
000636r 2  48                           pha
000637r 2  4C rr rr                     jmp i2crb_loop
00063Ar 2               ;
00063Ar 2  68           i2crb_end:      pla
00063Br 2  60                           rts
00063Cr 2               ;
00063Cr 2               ; i2cgb - get bit
00063Cr 2               ;
00063Cr 2  20 rr rr     i2cgb:          jsr i2cdh
00063Fr 2  20 rr rr                     jsr i2cch
000642r 2  AD 01 E1                     lda porta0
000645r 2  29 80                        and #SDA
000647r 2  D0 05                        bne i2cgb_1
000649r 2  A9 00                        lda #0
00064Br 2  4C rr rr                     jmp i2cgb_end
00064Er 2               ;
00064Er 2  A9 01        i2cgb_1:        lda #1
000650r 2               ;
000650r 2  20 rr rr     i2cgb_end:      jsr i2ccl
000653r 2  4C rr rr                     jmp i2cdl
000656r 2               ;
000656r 2               ; i2cst - start
000656r 2               ;
000656r 2               mi2cstr:
000656r 2               i2c_start:
000656r 2  20 rr rr     i2cst:          jsr i2cdl
000659r 2  EA                           nop
00065Ar 2  EA                           nop
00065Br 2  20 rr rr                     jsr i2ccl
00065Er 2  60                           rts
00065Fr 2               ;
00065Fr 2               ; i2csp - stop
00065Fr 2               ;
00065Fr 2               mi2cstp:
00065Fr 2               i2c_stop:
00065Fr 2  20 rr rr     i2csp:	        jsr i2cch
000662r 2  20 rr rr                     jsr i2cdh
000665r 2  60                           rts
000666r 2               ;
000666r 2               ; i2cak - ack
000666r 2               ;
000666r 2               mi2cack:
000666r 2               i2c_ack:
000666r 2  48           i2cak:          pha
000667r 2  A9 00                        lda #$00
000669r 2  20 rr rr                     jsr i2csb
00066Cr 2  68                           pla
00066Dr 2  60                           rts
00066Er 2               ;
00066Er 2               ; i2cnk - nack
00066Er 2               ;
00066Er 2               mi2cnak:
00066Er 2               i2c_nack:
00066Er 2  48           i2cnk:	        pha
00066Fr 2  A9 01                        lda #$01
000671r 2  20 rr rr                     jsr i2csb
000674r 2  68                           pla
000675r 2  60                           rts
000676r 2               ;
000676r 2               ; i2cdl - data  low
000676r 2               ;
000676r 2  48           i2cdl:          pha
000677r 2  AD 03 E1                     lda ddra0
00067Ar 2  09 80                        ora #SDA
00067Cr 2  8D 03 E1                     sta ddra0
00067Fr 2  AD 01 E1                     lda porta0
000682r 2  29 7F                        and #<~SDA
000684r 2  8D 01 E1                     sta porta0
000687r 2  68                           pla
000688r 2  60                           rts
000689r 2               ;
000689r 2               ; ic2dh - data high
000689r 2               ;
000689r 2  48           i2cdh:          pha
00068Ar 2  AD 03 E1                     lda ddra0
00068Dr 2  29 7F                        and #<~SDA
00068Fr 2  8D 03 E1                     sta ddra0
000692r 2  68                           pla
000693r 2  60                           rts
000694r 2               ;
000694r 2               ; i2ccl - clock low
000694r 2               ;
000694r 2  48           i2ccl:	        pha
000695r 2  AD 03 E1                     lda ddra0
000698r 2  09 40                        ora #SCL
00069Ar 2  8D 03 E1                     sta ddra0
00069Dr 2  AD 01 E1                     lda porta0
0006A0r 2  29 BF                        and #<~SCL
0006A2r 2  8D 01 E1                     sta porta0
0006A5r 2  68                           pla
0006A6r 2  60                           rts
0006A7r 2               ;
0006A7r 2               ; i2cch - clock high
0006A7r 2               ;
0006A7r 2  48           i2cch:	        pha
0006A8r 2  AD 03 E1                     lda ddra0
0006ABr 2  29 BF                        and #<~SCL
0006ADr 2  8D 03 E1                     sta ddra0
0006B0r 2  68                           pla
0006B1r 2  60                           rts
0006B2r 2               ;
0006B2r 2               
0006B2r 2               
0006B2r 2               
0006B2r 1               	.include "at24c.a65"
0006B2r 2               ;
0006B2r 2               ;----------------------------------------------------------
0006B2r 2               ; m65 - fs65sbc simple monitor
0006B2r 2               ;----------------------------------------------------------
0006B2r 2               ; at24c.a65 - i2c eeprom related routines
0006B2r 2               ; by Fabio Sturman (c) 2019,2023
0006B2r 2               ; fabio.sturman@gmail.com
0006B2r 2               ;----------------------------------------------------------
0006B2r 2               ;
0006B2r 2               ; AT24C256 read/write
0006B2r 2               ;
0006B2r 2               AT24C256	:= $a0
0006B2r 2               ;
0006B2r 2               mode	:= add
0006B2r 2               page	:= len
0006B2r 2               dmapo	:= data
0006B2r 2               counter	:= ra
0006B2r 2               ;
0006B2r 2               at24c_rd:
0006B2r 2  20 rr rr     	jsr i2c_init	;to idle state
0006B5r 2  20 rr rr     	jsr i2c_start
0006B8r 2  A9 A0        	lda #AT24C256
0006BAr 2  20 rr rr     	jsr i2c_write
0006BDr 2  F0 37        	beq @qe
0006BFr 2  A5 rr        	lda page+1
0006C1r 2  20 rr rr     	jsr i2c_write
0006C4r 2  F0 30        	beq @qe
0006C6r 2  A5 rr        	lda page
0006C8r 2  20 rr rr     	jsr i2c_write
0006CBr 2  F0 29        	beq @qe
0006CDr 2  20 rr rr     	jsr i2c_stop
0006D0r 2               ;
0006D0r 2  20 rr rr     	jsr i2c_start
0006D3r 2  A9 A1        	lda #AT24C256+1
0006D5r 2  20 rr rr     	jsr i2c_write
0006D8r 2               @l:
0006D8r 2  20 rr rr     	jsr i2c_read
0006DBr 2  92 rr        	sta (dmapo)
0006DDr 2  20 rr rr     	jsr i2c_ack
0006E0r 2  A2 rr 20 rr  	inc_x dmapo
0006E4r 2  rr           
0006E5r 2  A2 rr 20 rr  	dec_x counter
0006E9r 2  rr           
0006EAr 2  D0 EC        	bne @l
0006ECr 2  20 rr rr     	jsr i2c_nack
0006EFr 2  20 rr rr     	jsr i2c_stop
0006F2r 2  A9 00        	lda #0
0006F4r 2  80 05        	bra @q
0006F6r 2               @qe:
0006F6r 2  20 rr rr     	jsr i2c_init	;idle & return error
0006F9r 2  A9 A0        	lda #$a0
0006FBr 2               @q:
0006FBr 2  60           	rts
0006FCr 2               ;
0006FCr 2               ;
0006FCr 2               ;
0006FCr 2               at24c_wr:
0006FCr 2  20 rr rr     	jsr i2c_init
0006FFr 2  20 rr rr     	jsr i2c_start
000702r 2  A9 A0        	lda #AT24C256
000704r 2  20 rr rr     	jsr i2c_write
000707r 2  F0 28        	beq @qe
000709r 2  A5 rr        	lda page+1
00070Br 2  20 rr rr     	jsr i2c_write
00070Er 2  F0 21        	beq @qe
000710r 2  A5 rr        	lda page
000712r 2  20 rr rr     	jsr i2c_write
000715r 2  F0 1A        	beq @qe
000717r 2               @l:
000717r 2  B2 rr        	lda (dmapo)
000719r 2  20 rr rr     	jsr i2c_write
00071Cr 2  F0 13        	beq @qe
00071Er 2  A2 rr 20 rr  	inc_x dmapo
000722r 2  rr           
000723r 2  A2 rr 20 rr  	dec_x counter
000727r 2  rr           
000728r 2  D0 ED        	bne @l
00072Ar 2  20 rr rr     	jsr i2c_stop
00072Dr 2  A9 00        	lda #0
00072Fr 2  80 05        	bra @q
000731r 2               @qe:
000731r 2  20 rr rr     	jsr i2c_init	;error
000734r 2  A9 A1        	lda #$a1
000736r 2               @q:
000736r 2  60           	rts
000737r 2               ;
000737r 2               ; Q<0|1><p><a> r/w i2c 0=w 1=r  p=page64
000737r 2               ; add=r/w, len=p, data=a
000737r 2               ;
000737r 2               cmd_at24c:
000737r 2  20 rr rr     	jsr tpin_0
00073Ar 2  20 rr rr     	jsr get_par
00073Dr 2  A2 06        	ldx #6		;len*64
00073Fr 2               @l:
00073Fr 2  06 rr        	asl page
000741r 2  26 rr        	rol page+1
000743r 2  CA           	dex
000744r 2  D0 F9        	bne @l
000746r 2  A9 40 A0 00  	mov_n2x 64, counter		;num of bytes
00074Ar 2  85 rr 84 rr  
00074Er 2  A5 rr        	lda mode
000750r 2  29 01        	and #1
000752r 2  D0 10        	bne @r
000754r 2  20 rr rr     	jsr at24c_wr
000757r 2               @q:
000757r 2  20 rr rr     	jsr tpin_1
00075Ar 2  48           	pha
00075Br 2  A9 2E 20 rr  	print_c '.'
00075Fr 2  rr           
000760r 2  68           	pla
000761r 2  4C rr rr     	jmp put_cr_lf
000764r 2               @r:
000764r 2  20 rr rr     	jsr at24c_rd
000767r 2  80 EE        	bra @q
000769r 2               ;
000769r 2               ;-------------------------------------
000769r 2               ;     CLEAR A BLOCK OF MEMORY
000769r 2               ;-------------------------------------
000769r 2               BLOCK	:= $A00
000769r 2               N		:= $234
000769r 2               ;
000769r 2               
000769r 2               CLEAR:
000769r 2  20 rr rr     	jsr sw16
00076Cr 2               	.setcpu "sweet16"
00076Cr 2  10 00 00     	SET R0,0		;0 FOR CLEARING WITH
00076Fr 2  11 00 0A     	SET R1,BLOCK	;ADDRESS OF BLOCK
000772r 2  12 34 02     	SET R2,N		;# BYTES TO CLEAR
000775r 2               L1:
000775r 2  51           	ST @R1			;STORE IN BLOCK
000776r 2  F2           	DCR R2
000777r 2  07 FC        	BNZ L1			;NOT FINISHED YET
000779r 2  00           	RTN
00077Ar 2               ;
00077Ar 2               	.setcpu "65C02"
00077Ar 2               
00077Ar 1               	.include "tpin.a65"
00077Ar 2               ;-----------------------------------------------------------------------------
00077Ar 2               ; fsm65 fs monitor for 6502
00077Ar 2               ; Fabio Sturman (c) 2019,20,21,22
00077Ar 2               ; fabio.sturman@gmail.com
00077Ar 2               ;-----------------------------------------------------------------------------
00077Ar 2               ; tpin.a65
00077Ar 2               ; test pins on via0
00077Ar 2               ;-----------------------------------------------------------------------------
00077Ar 2               ;
00077Ar 2               ; tpin - test pin pb5
00077Ar 2               ;
00077Ar 2               TP_MASK         = %00100000
00077Ar 2               TP_DDR          = ddrb0
00077Ar 2               TP_PORT         = portb0
00077Ar 2               ;
00077Ar 2  AD 02 E1     tpin_init:      lda TP_DDR
00077Dr 2  09 20                        ora #TP_MASK
00077Fr 2  8D 02 E1                     sta TP_DDR
000782r 2               ;
000782r 2  48           tpin_1:         pha
000783r 2  AD 00 E1                     lda TP_PORT
000786r 2  09 20                        ora #TP_MASK
000788r 2  8D 00 E1                     sta TP_PORT
00078Br 2  68                           pla
00078Cr 2  60                           rts
00078Dr 2               ;
00078Dr 2  48           tpin_0:         pha
00078Er 2  AD 00 E1                     lda TP_PORT
000791r 2  29 DF                        and #<~TP_MASK
000793r 2  8D 00 E1                     sta TP_PORT
000796r 2  68                           pla
000797r 2  60                           rts
000798r 2               ;
000798r 2               ; toggle
000798r 2               ;
000798r 2  48           tpin_t:         pha
000799r 2  AD 00 E1                     lda TP_PORT
00079Cr 2  49 20                        eor #TP_MASK
00079Er 2  8D 00 E1                     sta TP_PORT
0007A1r 2  68                           pla
0007A2r 2  60                           rts
0007A3r 2               ;
0007A3r 2               
0007A3r 2               
0007A3r 1               	.include "sd_cf.a65"
0007A3r 2               ; SD card interface module
0007A3r 2               ;
0007A3r 2               ; Requires:
0007A3r 2               ;   sd_po   1 zero-page pointer
0007A3r 2               ;   sd_lba  uint32 sector number
0007A3r 2               ;   sd_cn   aux
0007A3r 2               ;
0007A3r 2               ;                    .DEFINE SD_DEBUG
0007A3r 2               ;
0007A3r 2                                   .IFDEF SD_DEBUG
0007A3r 2               ; printcd c debug print
0007A3r 2                                   .macro printcd c
0007A3r 2                                   lda #c
0007A3r 2                                   jsr putc
0007A3r 2                                   .endmacro
0007A3r 2                                   .ELSE
0007A3r 2                                   .macro printcd c
0007A3r 2                                   .endmacro
0007A3r 2                                   .ENDIF
0007A3r 2               ;
0007A3r 2                                   .macro SD_CS2HIGH
0007A3r 2                                   lda sd_port
0007A3r 2                                   ora #SD_CS
0007A3r 2                                   sta sd_port
0007A3r 2                                   .endmacro
0007A3r 2               ;
0007A3r 2                                   .macro SD_MOSI2HIGH
0007A3r 2                                   lda sd_port
0007A3r 2                                   ora #SD_MOSI
0007A3r 2                                   sta sd_port
0007A3r 2                                   .endmacro
0007A3r 2               ;
0007A3r 2                                   .macro SD_MOSI2LOW
0007A3r 2                                   lda sd_port
0007A3r 2                                   and #~SD_MOSI
0007A3r 2                                   sta sd_port
0007A3r 2                                   .endmacro
0007A3r 2               ;
0007A3r 2                                   .macro SD_CS2LOW
0007A3r 2                                   lda sd_port
0007A3r 2                                   and #<~SD_CS
0007A3r 2                                   sta sd_port
0007A3r 2                                   .endmacro
0007A3r 2               ;
0007A3r 2                                   .macro SD_CLK2LOW
0007A3r 2                                   lda sd_port
0007A3r 2                                   and #<~SD_SCK
0007A3r 2                                   sta sd_port
0007A3r 2                                   .endmacro
0007A3r 2               ;
0007A3r 2                                   .macro SD_CLK2HIGH
0007A3r 2                                   lda sd_port
0007A3r 2                                   ora #SD_SCK
0007A3r 2                                   sta sd_port
0007A3r 2                                   .endmacro
0007A3r 2               ;
0007A3r 2                                   .macro SD_8CLK
0007A3r 2                                   lda #255
0007A3r 2                                   jsr sd_write_byte
0007A3r 2                                   .endmacro
0007A3r 2               ;
0007A3r 2               SD_TRY			= 100
0007A3r 2               SD_TRY1			= 1700          ;~250ms
0007A3r 2               SD_MAX_RET		= 3
0007A3r 2               ;
0007A3r 2               sd_po			= ra
0007A3r 2               sd_cnt			= rb
0007A3r 2               ;
0007A3r 2               sd_ddr              = ddra0
0007A3r 2               sd_port             = porta0
0007A3r 2               sd_miso_ddr         = ddrb0
0007A3r 2               sd_miso_port        = portb0
0007A3r 2               SD_CS               = %00001000
0007A3r 2               SD_SCK              = %00010000
0007A3r 2               SD_MOSI             = %00100000
0007A3r 2               SD_MISO             = %10000000
0007A3r 2               SD_MASK             = (SD_SCK | SD_CS | SD_MOSI)
0007A3r 2               ;
0007A3r 2                                   .segment "CODE"
0007A3r 2               ;------------------------------------------
0007A3r 2               ; uint8 sd_init(void);
0007A3r 2               ; void __fastcall__ sd_set_sector_l(uint16 adl);
0007A3r 2               ; void __fastcall__ sd_set_sector_h(uint16 adh);
0007A3r 2               ; uint8 __fastcall__ sd_read_sector(uint8 *p);
0007A3r 2               ; uint8 __fastcall__ sd_write_sector(uint8 *p);
0007A3r 2               msdi:
0007A3r 2               cmd_sdi:
0007A3r 2               sd_init:
0007A3r 2               ; ck=0 mosi=1 cs=1
0007A3r 2               	;lda #$ff
0007A3r 2  A9 00        	lda #0
0007A5r 2  8D rr rr     	sta sd_lba
0007A8r 2  8D rr rr     	sta sd_lba+1
0007ABr 2  8D rr rr     	sta sd_lba+2
0007AEr 2  8D rr rr     	sta sd_lba+3
0007B1r 2               ;
0007B1r 2  AD 02 E1     	lda sd_miso_ddr   ; miso as input
0007B4r 2  29 7F        	and #~SD_MISO & 255
0007B6r 2  8D 02 E1                         sta sd_miso_ddr
0007B9r 2               ;
0007B9r 2  AD 01 E1                         lda sd_port
0007BCr 2  29 C7                            and #<~SD_MASK
0007BEr 2  09 28                            ora #SD_CS | SD_MOSI
0007C0r 2  8D 01 E1                         sta sd_port
0007C3r 2  AD 03 E1                         lda sd_ddr
0007C6r 2  29 C7                            and #<~SD_MASK
0007C8r 2  09 38                            ora #SD_CS | SD_MOSI | SD_SCK
0007CAr 2  8D 03 E1                         sta sd_ddr
0007CDr 2               ;
0007CDr 2  A0 0A                            ldy#10          ; send 80 clk pulses
0007CFr 2  5A           @0:                 phy
0007D0r 2  A9 FF                            lda #255
0007D2r 2  20 rr rr                         jsr sd_write_byte
0007D5r 2  7A                               ply
0007D6r 2  88                               dey
0007D7r 2  D0 F6                            bne @0
0007D9r 2               ; CMD0 - GO_IDLE_STATE - resets card to idle state, and SPI mode
0007D9r 2  A9 rr                            lda #<sd_cmd0_bytes
0007DBr 2  A2 rr                            ldx #>sd_cmd0_bytes
0007DDr 2  85 rr                            sta sd_po
0007DFr 2  86 rr                            stx sd_po+1
0007E1r 2  20 rr rr                         jsr sd_send_command
0007E4r 2               ; Expect status response $01 (not initialized)
0007E4r 2  C9 01                            cmp #$01
0007E6r 2  D0 53                            bne sd_init_x ;@initfailed
0007E8r 2               ; CMD8 - SEND_IF_COND - tell the card how we want it to operate (3.3V, etc)
0007E8r 2  A9 rr                            lda #<sd_cmd8_bytes
0007EAr 2  A2 rr                            ldx #>sd_cmd8_bytes
0007ECr 2  85 rr                            sta sd_po
0007EEr 2  86 rr                            stx sd_po+1
0007F0r 2  20 rr rr                         jsr sd_send_command
0007F3r 2               ; Expect status response $01 (not initialized)
0007F3r 2  C9 01                            cmp #$01
0007F5r 2  D0 44                            bne sd_init_x ;@initfailed
0007F7r 2                 ; Read 32-bit return value, but ignore it
0007F7r 2  20 rr rr                         jsr sd_read_byte
0007FAr 2  20 rr rr                         jsr sd_read_byte
0007FDr 2  20 rr rr                         jsr sd_read_byte
000800r 2  20 rr rr                         jsr sd_read_byte
000803r 2               ;
000803r 2               ; APP_CMD - required prefix for ACMD commands
000803r 2               ;
000803r 2  A9 64                            lda #SD_TRY
000805r 2  8D rr rr                         sta sd_nret
000808r 2               ;
000808r 2  A9 rr        sd_init_cmd55:      lda #<sd_cmd55_bytes
00080Ar 2  A2 rr                            ldx #>sd_cmd55_bytes
00080Cr 2  85 rr                            sta sd_po
00080Er 2  86 rr                            stx sd_po+1
000810r 2  20 rr rr                         jsr sd_send_command
000813r 2               ; Expect status response $01 (not initialized)
000813r 2  C9 01                            cmp #$01
000815r 2  D0 24                            bne sd_init_x  ;@initfailed
000817r 2               ; cmd 41  APP_SEND_OP_COND - send operating conditions, initialize card
000817r 2  A9 rr                            lda #<sd_cmd41_bytes
000819r 2  A2 rr                            ldx #>sd_cmd41_bytes
00081Br 2  85 rr                            sta sd_po
00081Dr 2  86 rr                            stx sd_po+1
00081Fr 2  20 rr rr                         jsr sd_send_command
000822r 2               ; Status response $00 means initialised
000822r 2  C9 00                            cmp #$00
000824r 2  F0 11                            beq sd_init_q ; initialized
000826r 2               ; Otherwise expect status response $01 (not initialized)
000826r 2  C9 01                            cmp #$01
000828r 2  D0 11                            bne sd_init_x ; initfailed
00082Ar 2               ;
00082Ar 2               ; Not initialized yet, so wait a while then try again.
00082Ar 2               ; This retry is important, to give the card time to initialize.
00082Ar 2               ;
00082Ar 2  CE rr rr                         dec sd_nret
00082Dr 2  F0 0C                            beq sd_init_x
00082Fr 2  A0 64                            ldy #100 ;50 ;20             ;delay 10ms
000831r 2  20 rr rr                         jsr delayhalfms
000834r 2  4C rr rr                         jmp sd_init_cmd55
000837r 2               ;
000837r 2  A9 00        sd_init_q:          lda #0
000839r 2  F0 0A                            beq sd_init_x0
00083Br 2               ;
00083Br 2  AD 01 E1 09  sd_init_x:          SD_CS2HIGH
00083Fr 2  08 8D 01 E1  
000843r 2  A9 80                            lda #$80
000845r 2  60           sd_init_x0:         rts
000846r 2               ;
000846r 2               ; commands table with parametrs and crc
000846r 2               ;
000846r 2  40 00 00 00  sd_cmd0_bytes:      .byte $40, $00, $00, $00, $00, $95
00084Ar 2  00 95        
00084Cr 2  48 00 00 01  sd_cmd8_bytes:      .byte $48, $00, $00, $01, $aa, $87
000850r 2  AA 87        
000852r 2  77 00 00 00  sd_cmd55_bytes:     .byte $77, $00, $00, $00, $00, $01
000856r 2  00 01        
000858r 2  69 40 00 00  sd_cmd41_bytes:     .byte $69, $40, $00, $00, $00, $01
00085Cr 2  00 01        
00085Er 2               ;
00085Er 2               ; sd_read_byte
00085Er 2               ; reads 1 byte from sdcard
00085Er 2  A2 FE        sd_read_byte:       ldx #$fe    ; Preloaded with seven ones and a zero, so we stop after eight bits
000860r 2  AD 01 E1 09                      SD_MOSI2HIGH
000864r 2  20 8D 01 E1  
000868r 2               ;
000868r 2  AD 01 E1 09  @0:                 SD_CLK2HIGH
00086Cr 2  10 8D 01 E1  
000870r 2  2C 00 E1                         bit sd_miso_port
000873r 2  18                               clc                         ; default to clearing the bottom bit
000874r 2  10 01                            bpl @1
000876r 2  38                               sec
000877r 2               ;                            ; in which case get ready to set the bottom bit
000877r 2  AD 01 E1 29  @1:                 SD_CLK2LOW
00087Br 2  EF 8D 01 E1  
00087Fr 2  8A                               txa                         ; transfer partial result from X
000880r 2  2A                               rol                         ; rotate carry bit into read result, and loop bit into carry
000881r 2  AA                               tax                         ; save partial result back to X
000882r 2  B0 E4                            bcs @0 ;@loop                   ; loop if we need to read more bits
000884r 2  60                               rts
000885r 2               ; sd_write byte
000885r 2               ; write byte in a to spi
000885r 2  A2 08        sd_write_byte:      ldx #8          ; send 8 bits
000887r 2               ;
000887r 2  0A           @0:                 asl             ; shift next bit into carry
000888r 2  A8                               tay             ; save remaining bits for later
000889r 2  AD 01 E1                         lda sd_port
00088Cr 2  29 DF                            and #<~SD_MOSI
00088Er 2  90 02                            bcc @1          ; if carry clear, don't set MOSI for this bit
000890r 2  09 20                            ora #SD_MOSI
000892r 2               
000892r 2  8D 01 E1     @1:                 sta sd_port     ; data in mosi
000895r 2  AD 01 E1 09                      SD_CLK2HIGH     ; ck=1
000899r 2  10 8D 01 E1  
00089Dr 2                                   ;;nop
00089Dr 2  AD 01 E1 29                      SD_CLK2LOW      ; ck=0
0008A1r 2  EF 8D 01 E1  
0008A5r 2  98                               tya             ; restore remaining bits to send
0008A6r 2  CA                               dex
0008A7r 2  D0 DE                            bne @0          ; loop if there are more bits to send
0008A9r 2  60                               rts
0008AAr 2               ;
0008AAr 2               ; wait for response read max SD_TRY1 times
0008AAr 2  A9 A4 A0 06  sd_wait_result:     mov_n2x SD_TRY1, sd_cnt
0008AEr 2  85 rr 84 rr  
0008B2r 2  20 rr rr     @1:                 jsr sd_read_byte
0008B5r 2  C9 FF                            cmp #$ff
0008B7r 2  D0 09                            bne @2
0008B9r 2  A2 rr 20 rr                      dec_x sd_cnt
0008BDr 2  rr           
0008BEr 2  D0 F2                            bne @1
0008C0r 2  A9 FF                            lda #$ff
0008C2r 2  60           @2:                 rts
0008C3r 2               ;
0008C3r 2               ; send command
0008C3r 2               ;
0008C3r 2  A9 FF 20 rr  sd_send_command:    SD_8CLK
0008C7r 2  rr           
0008C8r 2  AD 01 E1 29                      SD_CS2LOW           ; pull CS low to begin command
0008CCr 2  F7 8D 01 E1  
0008D0r 2  A9 FF 20 rr                      SD_8CLK
0008D4r 2  rr           
0008D5r 2  A0 00                            ldy #0
0008D7r 2  B1 rr                            lda (sd_po),y    ; command byte
0008D9r 2  20 rr rr                         jsr sd_write_byte
0008DCr 2  A0 01                            ldy #1
0008DEr 2  B1 rr                            lda (sd_po),y    ; data 1
0008E0r 2  20 rr rr                         jsr sd_write_byte
0008E3r 2  A0 02                            ldy #2
0008E5r 2  B1 rr                            lda (sd_po),y    ; data 2
0008E7r 2  20 rr rr                         jsr sd_write_byte
0008EAr 2  A0 03                            ldy #3
0008ECr 2  B1 rr                            lda (sd_po),y    ; data 3
0008EEr 2  20 rr rr                         jsr sd_write_byte
0008F1r 2  A0 04                            ldy #4
0008F3r 2  B1 rr                            lda (sd_po),y    ; data 4
0008F5r 2  20 rr rr                         jsr sd_write_byte
0008F8r 2  A0 05                            ldy #5
0008FAr 2  B1 rr                            lda (sd_po),y    ; crc
0008FCr 2  20 rr rr                         jsr sd_write_byte
0008FFr 2               ;
0008FFr 2  20 rr rr                         jsr sd_wait_result
000902r 2  48                               pha
000903r 2  A9 FF 20 rr                      SD_8CLK
000907r 2  rr           
000908r 2  AD 01 E1 09                      SD_CS2HIGH
00090Cr 2  08 8D 01 E1  
000910r 2  A9 FF 20 rr                      SD_8CLK
000914r 2  rr           
000915r 2  68                               pla
000916r 2  60                               rts
000917r 2               ;
000917r 2               ; sd_set_sector_l
000917r 2               ; saves ax in sd_lba low word
000917r 2               ;
000917r 2               msdll:
000917r 2  8D rr rr     sd_set_sector_l:    sta sd_lba
00091Ar 2  8E rr rr                         stx sd_lba+1
00091Dr 2  60                               rts
00091Er 2               ;
00091Er 2               ; sd_set_sector_h
00091Er 2               ; saves ax in sd_lba high word
00091Er 2               ;
00091Er 2               msdlh:
00091Er 2  8D rr rr     sd_set_sector_h:    sta sd_lba+2
000921r 2  8E rr rr                         stx sd_lba+3
000924r 2  60                               rts
000925r 2               ;
000925r 2               ; sd_read_sector
000925r 2               ; reads sector retrying SD_MAX_RET times
000925r 2               ;
000925r 2               msdr:
000925r 2  85 rr        sd_read_sector:     sta sd_po
000927r 2  86 rr                            stx sd_po+1
000929r 2  A0 03                            ldy #SD_MAX_RET
00092Br 2  20 rr rr     @2:                 jsr sd_read_sectork
00092Er 2  C9 00                            cmp #0
000930r 2  F0 03                            beq @1
000932r 2  88                               dey
000933r 2  D0 F6                            bne @2
000935r 2  60           @1:                 rts
000936r 2               ;
000936r 2               ; sd_read_sectork
000936r 2               ; reads sector once
000936r 2               ;
000936r 2  5A           sd_read_sectork:    phy                 ; save y
000937r 2  A9 FF 20 rr                      SD_8CLK
00093Br 2  rr           
00093Cr 2  AD 01 E1 29                      SD_CS2LOW           ; pull CS low to begin command
000940r 2  F7 8D 01 E1  
000944r 2  A9 FF 20 rr                      SD_8CLK
000948r 2  rr           
000949r 2               ;
000949r 2               ; CMD17, arg is sector number, crc not checked
000949r 2               ;
000949r 2  A9 51                            lda #$51
00094Br 2  20 rr rr                         jsr sd_write_byte
00094Er 2  AD rr rr                         lda sd_lba+3        ; lba address
000951r 2  20 rr rr                         jsr sd_write_byte
000954r 2  AD rr rr                         lda sd_lba+2
000957r 2  20 rr rr                         jsr sd_write_byte
00095Ar 2  AD rr rr                         lda sd_lba+1
00095Dr 2  20 rr rr                         jsr sd_write_byte
000960r 2  AD rr rr                         lda sd_lba
000963r 2  20 rr rr                         jsr sd_write_byte
000966r 2  A9 01                            lda #$01             ; crc (not checked)
000968r 2  20 rr rr                         jsr sd_write_byte
00096Br 2               ;
00096Br 2  20 rr rr                         jsr sd_wait_result
00096Er 2  C9 00                            cmp #$00
000970r 2  D0 2D                            bne @x
000972r 2               ; wait for data
000972r 2  20 rr rr                         jsr sd_wait_result
000975r 2  C9 FE                            cmp #$fe
000977r 2  D0 26                            bne @x
000979r 2               ; read 512 bytes - two pages of 256 bytes each
000979r 2  20 rr rr                         jsr sd_read_page
00097Cr 2  E6 rr                            inc sd_po+1
00097Er 2  20 rr rr                         jsr sd_read_page
000981r 2  C6 rr                            dec sd_po+1
000983r 2  20 rr rr                         jsr sd_read_byte ;crc
000986r 2  20 rr rr                         jsr sd_read_byte
000989r 2               ;
000989r 2  A9 FF 20 rr                      SD_8CLK
00098Dr 2  rr           
00098Er 2  AD 01 E1 09                      SD_CS2HIGH
000992r 2  08 8D 01 E1  
000996r 2  A9 FF 20 rr                      SD_8CLK
00099Ar 2  rr           
00099Br 2               ;
00099Br 2  A9 00                            lda #0
00099Dr 2  F0 0A                            beq @x0
00099Fr 2  AD 01 E1 09  @x:                 SD_CS2HIGH
0009A3r 2  08 8D 01 E1  
0009A7r 2  A9 81                            lda #$81
0009A9r 2  7A           @x0:                ply
0009AAr 2  60                               rts
0009ABr 2               ;
0009ABr 2               ; Read 256 bytes to the address at sd_po
0009ABr 2               ;
0009ABr 2  A0 00        sd_read_page:       ldy #0
0009ADr 2  20 rr rr     @1:                 jsr sd_read_byte
0009B0r 2  91 rr                            sta (sd_po),y
0009B2r 2  C8                               iny
0009B3r 2  D0 F8                            bne @1
0009B5r 2  60                               rts
0009B6r 2               ;
0009B6r 2               ; sd_write_sector
0009B6r 2               ; reads sector retrying SD_MAX_RET
0009B6r 2               ;
0009B6r 2               msdw:
0009B6r 2  85 rr        sd_write_sector:    sta sd_po
0009B8r 2  86 rr                            stx sd_po+1
0009BAr 2  A0 03                            ldy #SD_MAX_RET
0009BCr 2  20 rr rr     @2:                 jsr sd_write_sectork
0009BFr 2  C9 00                            cmp #0
0009C1r 2  F0 03                            beq @1
0009C3r 2  88                               dey
0009C4r 2  D0 F6                            bne @2
0009C6r 2  60           @1:                 rts
0009C7r 2               ;
0009C7r 2               ; sd_write_sectork
0009C7r 2               ; write sector once
0009C7r 2               ;
0009C7r 2  5A           sd_write_sectork:   phy
0009C8r 2                                   printcd 'w'         ; debug printing
0009C8r 2  A9 FF 20 rr                      SD_8CLK
0009CCr 2  rr           
0009CDr 2  AD 01 E1 29                      SD_CS2LOW           ; pull CS low to begin command
0009D1r 2  F7 8D 01 E1  
0009D5r 2  A9 FF 20 rr                      SD_8CLK
0009D9r 2  rr           
0009DAr 2               ; Command 24, arg is sector number, crc not checked
0009DAr 2  A9 58                            lda #$58                    ; CMD24 - WRITE_SINGLE_BLOCK
0009DCr 2  20 rr rr                         jsr sd_write_byte
0009DFr 2  AD rr rr                         lda sd_lba+3        ; lba address
0009E2r 2  20 rr rr                         jsr sd_write_byte
0009E5r 2  AD rr rr                         lda sd_lba+2
0009E8r 2  20 rr rr                         jsr sd_write_byte
0009EBr 2  AD rr rr                         lda sd_lba+1
0009EEr 2  20 rr rr                         jsr sd_write_byte
0009F1r 2  AD rr rr                         lda sd_lba
0009F4r 2  20 rr rr                         jsr sd_write_byte
0009F7r 2  A9 01                            lda #$01             ; crc (not checked)
0009F9r 2  20 rr rr                         jsr sd_write_byte
0009FCr 2                                   printcd '0'
0009FCr 2  20 rr rr                         jsr sd_wait_result
0009FFr 2  C9 00                            cmp #$00
000A01r 2  D0 46                            bne sd_write_sector_x
000A03r 2                                   printcd '1'
000A03r 2  A9 FE                            lda #$fe
000A05r 2  20 rr rr                         jsr sd_write_byte
000A08r 2                                   printcd '2'
000A08r 2               ; Need to write 512 bytes - two pages of 256 bytes each
000A08r 2  20 rr rr                         jsr sd_write_page
000A0Br 2  E6 rr                            inc sd_po+1
000A0Dr 2  20 rr rr                         jsr sd_write_page
000A10r 2  C6 rr                            dec sd_po+1
000A12r 2               ;
000A12r 2  20 rr rr                         jsr sd_wait_result ;sd_read_byte        ; test if data accepted
000A15r 2  29 1F                            and #%00011111
000A17r 2  C9 05                            cmp #5
000A19r 2  D0 2E                            bne sd_write_sector_x
000A1Br 2               ;
000A1Br 2  A9 A4 A0 06                      mov_n2x SD_TRY1, sd_cnt ; id data accepted wait unill sd free
000A1Fr 2  85 rr 84 rr  
000A23r 2  20 rr rr     sd_write_sector_0:  jsr sd_read_byte
000A26r 2  C9 00                            cmp #0
000A28r 2  D0 09                            bne sd_write_sector_q
000A2Ar 2  A2 rr 20 rr                      dec_x sd_cnt
000A2Er 2  rr           
000A2Fr 2  D0 F2                            bne sd_write_sector_0
000A31r 2  80 16                            bra sd_write_sector_x  ; timeout
000A33r 2               ;
000A33r 2               sd_write_sector_q:  printcd 'e'
000A33r 2  A9 FF 20 rr                      SD_8CLK
000A37r 2  rr           
000A38r 2  AD 01 E1 09                      SD_CS2HIGH
000A3Cr 2  08 8D 01 E1  
000A40r 2  A9 FF 20 rr                      SD_8CLK
000A44r 2  rr           
000A45r 2               ;
000A45r 2  A9 00                            lda #0
000A47r 2  F0 0A                            beq sd_write_sector_x0
000A49r 2               ;
000A49r 2  AD 01 E1 09  sd_write_sector_x:  SD_CS2HIGH
000A4Dr 2  08 8D 01 E1  
000A51r 2  A9 82                            lda #$82
000A53r 2               ;
000A53r 2  7A           sd_write_sector_x0: ply
000A54r 2  60                               rts
000A55r 2               ;
000A55r 2  A0 00        sd_write_page:      ldy #0
000A57r 2  B1 rr        @0:                 lda (sd_po),y
000A59r 2  5A                               phy
000A5Ar 2  20 rr rr                         jsr sd_write_byte
000A5Dr 2  7A                               ply
000A5Er 2  C8                               iny
000A5Fr 2  D0 F6                            bne @0
000A61r 2  60                               rts
000A62r 2               ;
000A62r 2               ;----------------------------------------------------------
000A62r 2               ;----------------------------------------------------------
000A62r 2               ;  CF - compact flash
000A62r 2               ;----------------------------------------------------------
000A62r 2               ;----------------------------------------------------------
000A62r 2               ;
000A62r 2               CF_DATA		= ide0+0		; Data (R/W)
000A62r 2               CF_ERR		= ide0+1		; Error register (R)
000A62r 2               CF_FEAT		= ide0+1		; Features (W)
000A62r 2               CF_SECCO	= ide0+2		; Sector count (R/W)
000A62r 2               CF_LBA0		= ide0+3		; LBA bits 0-7 (R/W, LBA mode)
000A62r 2               CF_LBA1		= ide0+4		; LBA bits 8-15 (R/W, LBA mode)
000A62r 2               CF_LBA2		= ide0+5		; LBA bits 16-23 (R/W, LBA mode)
000A62r 2               CF_LBA3		= ide0+6		; LBA bits 24-27 (R/W, LBA mode)
000A62r 2               CF_STAT		= ide0+7		; Status (R)
000A62r 2               CF_CMD		= ide0+7		; Command (W)
000A62r 2               ;
000A62r 2               CF_NRTRY	= 64000
000A62r 2               ;
000A62r 2               ;----------------------------------------------------------
000A62r 2               ; cf_rdy - ready to execute cmd
000A62r 2               ; uses: rd, a, x
000A62r 2               ; in:   -
000A62r 2               ; out:  Z=1 ok
000A62r 2               ;       Z=0 er
000A62r 2               ;----------------------------------------------------------
000A62r 2               ;
000A62r 2               cf_rdy:
000A62r 2  A9 00 A0 FA  	mov_n2x CF_NRTRY, rd
000A66r 2  85 rr 84 rr  
000A6Ar 2               @l:
000A6Ar 2  AD 07 E2     	lda CF_STAT
000A6Dr 2  29 C0        	and #%11000000
000A6Fr 2  C9 40        	cmp #%01000000
000A71r 2  F0 0B        	beq @te
000A73r 2  A2 rr 20 rr  	dec_x rd
000A77r 2  rr           
000A78r 2  D0 F0        	bne @l
000A7Ar 2  A9 02        	lda #2
000A7Cr 2  80 05        	bra @q
000A7Er 2               @te:
000A7Er 2  AD 07 E2     	lda CF_STAT
000A81r 2  29 01        	and #1
000A83r 2               @q:
000A83r 2  60           	rts
000A84r 2               ;
000A84r 2               ;----------------------------------------------------------
000A84r 2               ; cf_drq - data request
000A84r 2               ; uses: a, x, rega
000A84r 2               ; in:   -
000A84r 2               ; out:  Z=1 ok
000A84r 2               ;       Z=0 er
000A84r 2               ;----------------------------------------------------------
000A84r 2               ;
000A84r 2               cf_drq:
000A84r 2  A9 00 A0 FA  	mov_n2x CF_NRTRY, rd
000A88r 2  85 rr 84 rr  
000A8Cr 2               @l:
000A8Cr 2  AD 07 E2     	lda CF_STAT
000A8Fr 2  29 88        	and #%10001000
000A91r 2  C9 08        	cmp #%00001000
000A93r 2  F0 0B        	beq @te
000A95r 2  A2 rr 20 rr  	dec_x rd
000A99r 2  rr           
000A9Ar 2  D0 F0        	bne @l
000A9Cr 2  A9 03        	lda #3
000A9Er 2  80 05        	bra @q
000AA0r 2               @te:
000AA0r 2  AD 07 E2     	lda CF_STAT
000AA3r 2  29 01        	and #1
000AA5r 2               @q:
000AA5r 2  60           	rts
000AA6r 2               ;
000AA6r 2               ;----------------------------------------------------------
000AA6r 2               ; cf_init - init cf card
000AA6r 2               ; in:  none
000AA6r 2               ; out: d0=0 if ok
000AA6r 2               ;      d0=$90 if er
000AA6r 2               ;----------------------------------------------------------
000AA6r 2               ; init SD, CF
000AA6r 2               mcfi:
000AA6r 2               cmd_cfi:
000AA6r 2               cf_init:
000AA6r 2  A9 00        	lda #0
000AA8r 2  8D rr rr     	sta cf_lba
000AABr 2  8D rr rr     	sta cf_lba+1
000AAEr 2  8D rr rr     	sta cf_lba+2
000AB1r 2  8D rr rr     	sta cf_lba+3
000AB4r 2               ;
000AB4r 2  20 rr rr     	jsr cf_rdy
000AB7r 2  D0 1D        	bne @e
000AB9r 2  A9 01        	lda #1
000ABBr 2  8D 01 E2     	sta CF_FEAT		; 8 bit transfer
000ABEr 2  A9 EF        	lda #$ef
000AC0r 2  8D 07 E2     	sta CF_CMD		; set feature
000AC3r 2  20 rr rr     	jsr cf_rdy
000AC6r 2  D0 0E        	bne @e
000AC8r 2  A9 82        	lda #$82
000ACAr 2  8D 01 E2     	sta CF_FEAT		; no write caching
000ACDr 2  A9 EF        	lda #$ef
000ACFr 2  8D 07 E2     	sta CF_CMD		; set feature
000AD2r 2  A9 00        	lda #0
000AD4r 2  80 02        	bra @q
000AD6r 2               @e:
000AD6r 2  A9 C0        	lda #$c0
000AD8r 2               @q:
000AD8r 2  60           	rts
000AD9r 2               ;
000AD9r 2               ;----------------------------------------------------------
000AD9r 2               ; cf_rds
000AD9r 2               ;
000AD9r 2               ; ax=dma
000AD9r 2               ; cf_lba=lba
000AD9r 2               ;----------------------------------------------------------
000AD9r 2               ;
000AD9r 2               mcfr:
000AD9r 2               cf_rds:
000AD9r 2  20 rr rr     	jsr cf_rwc
000ADCr 2  A9 20        	lda #$20	;#$ec	;to read drive info
000ADEr 2  8D 07 E2     	sta CF_CMD		; read sec
000AE1r 2  20 rr rr     	jsr cf_drq
000AE4r 2  D0 1D        	bne @e1
000AE6r 2               ;
000AE6r 2  A0 00        	ldy #0
000AE8r 2               @l:
000AE8r 2  AD 00 E2     	lda CF_DATA
000AEBr 2  91 rr        	sta (po),y
000AEDr 2  C8           	iny
000AEEr 2  D0 F8        	bne @l
000AF0r 2               ;
000AF0r 2  E6 rr        	inc po+1
000AF2r 2               @ll:
000AF2r 2  AD 00 E2     	lda CF_DATA
000AF5r 2  91 rr        	sta (po),y
000AF7r 2  C8           	iny
000AF8r 2  D0 F8        	bne @ll
000AFAr 2               ;
000AFAr 2  20 rr rr     	jsr cf_rdy
000AFDr 2  D0 08        	bne @e3
000AFFr 2  A9 00        	lda #0
000B01r 2  80 06        	bra @q
000B03r 2               @e1:
000B03r 2  A9 C1        	lda #$c1
000B05r 2  80 02        	bra @q
000B07r 2               @e3:
000B07r 2  A9 C3        	lda #$c3
000B09r 2               @q:
000B09r 2  60           	rts
000B0Ar 2               ;
000B0Ar 2               ;----------------------------------------------------------
000B0Ar 2               ; cf_wrs - cf write sector 512
000B0Ar 2               ;
000B0Ar 2               ; a0=dma
000B0Ar 2               ; d0=lba
000B0Ar 2               ;----------------------------------------------------------
000B0Ar 2               ;
000B0Ar 2               mcfw:
000B0Ar 2               cf_wrs:
000B0Ar 2  20 rr rr     	jsr cf_rwc
000B0Dr 2  A9 30        	lda #$30
000B0Fr 2  8D 07 E2     	sta CF_CMD		; wr sec
000B12r 2  20 rr rr     	jsr cf_drq
000B15r 2  D0 1D        	bne @e2
000B17r 2               ;
000B17r 2  A0 00        	ldy #0
000B19r 2               @l:
000B19r 2  B1 rr        	lda (po),y
000B1Br 2  8D 00 E2     	sta CF_DATA
000B1Er 2  C8           	iny
000B1Fr 2  D0 F8        	bne @l
000B21r 2               ;
000B21r 2  E6 rr        	inc po+1
000B23r 2               @ll:
000B23r 2  B1 rr        	lda (po),y
000B25r 2  8D 00 E2     	sta CF_DATA
000B28r 2  C8           	iny
000B29r 2  D0 F8        	bne @ll
000B2Br 2               ;
000B2Br 2  20 rr rr     	jsr cf_rdy
000B2Er 2  D0 08        	bne @e4
000B30r 2  A9 00        	lda #0
000B32r 2  80 06        	bra @q
000B34r 2               @e2:
000B34r 2  A9 C2        	lda #$c2
000B36r 2  80 02        	bra @q
000B38r 2               @e4:
000B38r 2  A9 C4        	lda #$c4
000B3Ar 2               @q:
000B3Ar 2  60           	rts
000B3Br 2               ;
000B3Br 2               ;----------------------------------------------------------
000B3Br 2               ; cf_rwc - common to rd & wr
000B3Br 2               ;----------------------------------------------------------
000B3Br 2               ;
000B3Br 2               cf_rwc:
000B3Br 2  85 rr 86 rr  	mov_ax2x po
000B3Fr 2  A9 01        	lda #1
000B41r 2  8D 02 E2     	sta CF_SECCO		; 1 sec rd or wr
000B44r 2  AD rr rr     	lda cf_lba
000B47r 2  8D 03 E2     	sta CF_LBA0
000B4Ar 2  AD rr rr     	lda cf_lba+1
000B4Dr 2  8D 04 E2     	sta CF_LBA1
000B50r 2  AD rr rr     	lda cf_lba+2
000B53r 2  8D 05 E2     	sta CF_LBA2
000B56r 2  AD rr rr     	lda cf_lba+3
000B59r 2  29 EF        	and #%11101111		; drive 0
000B5Br 2  09 40        	ora #%01000000		; lba
000B5Dr 2  8D 06 E2     	sta CF_LBA3
000B60r 2  60           	rts
000B61r 2               ;
000B61r 2               ;----------------------------------------------------------
000B61r 2               ; cf_set_sector_l
000B61r 2               ; saves ax in cf_lba low word
000B61r 2               ;----------------------------------------------------------
000B61r 2               ;
000B61r 2               mcfll:
000B61r 2               cf_set_sector_l:
000B61r 2  8D rr rr     	sta cf_lba
000B64r 2  8E rr rr     	stx cf_lba+1
000B67r 2  60           	rts
000B68r 2               ;
000B68r 2               ;----------------------------------------------------------
000B68r 2               ; cf_set_sector_h
000B68r 2               ; saves ax in cf_lba high word
000B68r 2               ;----------------------------------------------------------
000B68r 2               ;
000B68r 2               mcflh:
000B68r 2               cf_set_sector_h:
000B68r 2  8D rr rr     	sta cf_lba+2
000B6Br 2  8E rr rr     	stx cf_lba+3
000B6Er 2  60           	rts
000B6Fr 2               ;
000B6Fr 2               
000B6Fr 2               
000B6Fr 2               
000B6Fr 1               ;
000B6Fr 1               ;----------------------------------------------------------
000B6Fr 1               ; main monitor entr after reset
000B6Fr 1               ;----------------------------------------------------------
000B6Fr 1               ;
000B6Fr 1               cold:
000B6Fr 1  78           	sei
000B70r 1  D8           	cld
000B71r 1  A2 FF        	ldx #$FF
000B73r 1  9A           	txs
000B74r 1               ;
000B74r 1  58           	cli
000B75r 1  20 rr rr     	jsr init
000B78r 1  20 rr rr     	print_cr_lf
000B7Br 1  20 rr rr     	jsr sd_init
000B7Er 1  20 rr rr     	jsr put_error
000B81r 1  20 rr rr     	jsr cf_init
000B84r 1  20 rr rr     	jsr put_error
000B87r 1               ;
000B87r 1  A9 rr A0 rr  	print_s msg_greetings
000B8Br 1  20 rr rr     
000B8Er 1  20 rr rr     	jsr time_rd
000B91r 1  A9 00 A0 02  	mov_n2x work_area, add
000B95r 1  85 rr 84 rr  
000B99r 1  A9 00 A0 01  	mov_n2x $0100, len
000B9Dr 1  85 rr 84 rr  
000BA1r 1  A9 00 A0 00  	mov_n2x $0000, data
000BA5r 1  85 rr 84 rr  
000BA9r 1  A9 00        	lda #0
000BABr 1  4C rr rr     	jmp warm
000BAEr 1               ;
000BAEr 1               ; initialization routine
000BAEr 1               ;
000BAEr 1               init:
000BAEr 1  9C rr rr     	stz fsmflags		;bit 7 buzzer, bit 6 echo, bit 5 sd init
000BB1r 1  A9 80        	lda #$80
000BB3r 1  8D rr rr     	sta fsmflags
000BB6r 1  20 rr rr     	jsr pmu_init		;paged memory unit
000BB9r 1  20 rr rr     	jsr acia_init
000BBCr 1  20 rr rr     	jsr acia1_init
000BBFr 1  20 rr rr     	jsr i2c_init
000BC2r 1  20 rr rr     	jsr rtc_init
000BC5r 1  20 rr rr     	jsr tpin_init
000BC8r 1               	;jsr tpin_0
000BC8r 1  20 rr rr     	jsr timers_init
000BCBr 1  20 rr rr     	jsr buzzer_init
000BCEr 1               ;
000BCEr 1  9C rr rr     	stz last_cmd
000BD1r 1  9C rr rr     	stz reg_a
000BD4r 1  9C rr rr     	stz reg_x
000BD7r 1  9C rr rr     	stz reg_y
000BDAr 1  BA           	tsx
000BDBr 1  8E rr rr     	stx reg_sp
000BDEr 1  A9 00        	lda #0		;z=0
000BE0r 1  18           	clc			;c=0
000BE1r 1  08           	php
000BE2r 1  68           	pla
000BE3r 1  29 FB        	and #%11111011	;clear interrupt flag (cli)
000BE5r 1  8D rr rr     	sta reg_cc
000BE8r 1               ;
000BE8r 1               ; init main vectors
000BE8r 1               ;
000BE8r 1  A9 00 A0 02  	mov_n2x $200, reg_pc
000BECr 1  8D rr rr 8C  
000BF0r 1  rr rr        
000BF2r 1  A9 rr A0 rr  	mov_n2x brk_exe, brk_vec
000BF6r 1  8D rr rr 8C  
000BFAr 1  rr rr        
000BFCr 1  A9 rr A0 rr  	mov_n2x via_int, irq_vec	;acia_int, irq_vec
000C00r 1  8D rr rr 8C  
000C04r 1  rr rr        
000C06r 1  A9 rr A0 rr  	mov_n2x int_exit, nmi_vec
000C0Ar 1  8D rr rr 8C  
000C0Er 1  rr rr        
000C10r 1  A9 rr A0 rr  	mov_n2x put_c_blk, putc_vec
000C14r 1  8D rr rr 8C  
000C18r 1  rr rr        
000C1Ar 1  A9 rr A0 rr  	mov_n2x get_c_blk, getc_vec
000C1Er 1  8D rr rr 8C  
000C22r 1  rr rr        
000C24r 1               initq:
000C24r 1  60           	rts
000C25r 1               ;
000C25r 1               put_error:
000C25r 1  C9 00        	cmp #ER_NONE
000C27r 1  F0 12        	beq @q
000C29r 1  48           	pha
000C2Ar 1  A9 rr A0 rr  	print_s msg_err
000C2Er 1  20 rr rr     
000C31r 1  68           	pla
000C32r 1  20 rr rr     	jsr put_c_hex
000C35r 1  20 rr rr     	jsr put_cr_lf
000C38r 1  20 rr rr     	jsr beep
000C3Br 1               @q:
000C3Br 1  60           	rts
000C3Cr 1               ;
000C3Cr 1               ;----------------------------------------------------------
000C3Cr 1               ; Messages/strings
000C3Cr 1               ;----------------------------------------------------------
000C3Cr 1               ;
000C3Cr 1               msg_prompt:
000C3Cr 1  24 00        	.byte "$", 0	;"fsm65>", 0
000C3Er 1               msg_n_row:
000C3Er 1  20 20 20 20  	.byte "       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F", 0
000C42r 1  20 20 20 30  
000C46r 1  20 20 31 20  
000C74r 1               msg_c_row:
000C74r 1  20 20 20 20  	.byte "      0 1 2 3 4 5 6 7 8 9 A B C D E F", 0
000C78r 1  20 20 30 20  
000C7Cr 1  31 20 32 20  
000C9Ar 1               ;
000C9Ar 1               msg_greetings:
000C9Ar 1  6D 36 35 20  	.byte "m65 - fs65sbc monitor - Ver "
000C9Er 1  2D 20 66 73  
000CA2r 1  36 35 73 62  
000CB6r 1  30 2E 34 20  	.byte VERSIONH+$30, '.', VERSIONL+$30, " (c) 2019-23", CR, LF
000CBAr 1  28 63 29 20  
000CBEr 1  32 30 31 39  
000CC7r 1  62 79 20 46  	.byte "by F. Sturman - fabio.sturman@gmail.com - h|?=help", CR, LF, 0
000CCBr 1  2E 20 53 74  
000CCFr 1  75 72 6D 61  
000CFCr 1               
000CFCr 1               msg_help:
000CFCr 1               ;	.byte "No HELP!", CR, LF, 0
000CFCr 1               ;	.if 0
000CFCr 1  44 3C 61 3E  	.byte "D<a>,<l> hex dump | A<a>,<l> ascii dump", CR, LF
000D00r 1  2C 3C 6C 3E  
000D04r 1  20 68 65 78  
000D25r 1  46 3C 61 3E  	.byte "F<a>,<l>,<d> fill | J<a> jump", CR, LF
000D29r 1  2C 3C 6C 3E  
000D2Dr 1  2C 3C 64 3E  
000D44r 1  4D 3C 73 3E  	.byte "M<s>,<l>,<d> move | C<a> change", CR, LF
000D48r 1  2C 3C 6C 3E  
000D4Cr 1  2C 3C 64 3E  
000D65r 1  57 3C 61 3E  	.byte "W<a> watch        | X<a>,<d>,<m> r/w memory", CR, LF
000D69r 1  20 77 61 74  
000D6Dr 1  63 68 20 20  
000D92r 1  45 20 65 64  	.byte "E edit regs       | P print regs", CR, LF
000D96r 1  69 74 20 72  
000D9Ar 1  65 67 73 20  
000DB4r 1  59 20 73 79  	.byte "Y sys timer       | O, O0 boot CF; O1 boot SD", CR, LF
000DB8r 1  73 20 74 69  
000DBCr 1  6D 65 72 20  
000DE3r 1  23 20 78 78  	.byte "# xxx comment     | H, ? help", CR, LF
000DE7r 1  78 20 63 6F  
000DEBr 1  6D 6D 65 6E  
000E02r 1  4C 3C 6C 62  	.byte "L<lbal><l><a> load SD | S<lbal><l><a> save SD", CR, LF
000E06r 1  61 6C 3E 3C  
000E0Ar 1  6C 3E 3C 61  
000E31r 1  55 3C 6C 62  	.byte "U<lbal><l><a> load CF | V<lbal><l><a> save CF", CR, LF
000E35r 1  61 6C 3E 3C  
000E39r 1  6C 3E 3C 61  
000E60r 1  5A 2C 20 5A  	.byte "Z, Z0 reset CF - Z1 reset SD", CR, LF
000E64r 1  30 20 72 65  
000E68r 1  73 65 74 20  
000E7Er 1  51 3C 30 7C  	.byte "Q<0|1><p><a> r/w i2c 0=w 1=r  p=page64", CR, LF
000E82r 1  31 3E 3C 70  
000E86r 1  3E 3C 61 3E  
000EA6r 1  47 5B 3C 6C  	.byte "G[<lbah>] SD lba 2,3  | B<lbah>] CF lba 2,3", CR, LF
000EAAr 1  62 61 68 3E  
000EAEr 1  5D 20 53 44  
000ED3r 1  4E 5B 3C 70  	.byte "N[<p>] set/get pmu page", CR, LF
000ED7r 1  3E 5D 20 73  
000EDBr 1  65 74 2F 67  
000EECr 1  54 3C 61 3E  	.byte "T<a>,<l> tx intel hex", CR, LF
000EF0r 1  2C 3C 6C 3E  
000EF4r 1  20 74 78 20  
000F03r 1  3A 2E 2E 2E  	.byte ":... rx intel hex record", CR, LF
000F07r 1  20 72 78 20  
000F0Br 1  69 6E 74 65  
000F1Dr 1  49 5B 68 68  	.byte "I[hh:mm:ss DD.MM.YYYY] get/set time", CR, LF
000F21r 1  3A 6D 6D 3A  
000F25r 1  73 73 20 44  
000F42r 1  00           	.byte 0
000F43r 1               ;	.endif
000F43r 1               ;
000F43r 1               msg_hex_end_record:
000F43r 1  3A 30 30 30  	.byte ":00000001FF", 0
000F47r 1  30 30 30 30  
000F4Br 1  31 46 46 00  
000F4Fr 1               ;
000F4Fr 1               msg_err:
000F4Fr 1  45 72 72 6F  	.byte "Error: ", 0
000F53r 1  72 3A 20 00  
000F57r 1               ;
000F57r 1               msg_break:
000F57r 1  42 72 65 61  	.byte "Break", 0
000F5Br 1  6B 00        
000F5Dr 1               ;
000F5Dr 1               ;----------------------------------------------------------
000F5Dr 1               ;
000F5Dr 1               mwrm:
000F5Dr 1               warm:
000F5Dr 1  D8           	cld
000F5Er 1               ;
000F5Er 1               ; command lop
000F5Er 1               ; entry point after command execution
000F5Er 1               ;
000F5Er 1               cmd_loop:
000F5Er 1  20 rr rr     	jsr put_error
000F61r 1               ;
000F61r 1               ; print prompt
000F61r 1               ;
000F61r 1               cmd_loopc:
000F61r 1  A9 rr A0 rr  	print_s msg_prompt
000F65r 1  20 rr rr     
000F68r 1  20 rr rr     	jsr get_s
000F6Br 1  B0 F4        	bcs cmd_loopc	;aborted with ctrl-x
000F6Dr 1  20 rr rr     	jsr scani		;get first ch from buf
000F70r 1  F0 0D        	beq cmd_repeat	;if buf empty repeat
000F72r 1  20 rr rr     	jsr toupper
000F75r 1  C9 41        	cmp #'A'
000F77r 1  90 24        	bcc cmd_nolit	;test if # or :
000F79r 1  C9 5B        	cmp #$5b ;'['
000F7Br 1  90 32        	bcc cmd_decoder	;is alpha - decode
000F7Dr 1  B0 DF        	bcs cmd_loop
000F7Fr 1               ;
000F7Fr 1               ; command repeat
000F7Fr 1               ;
000F7Fr 1               cmd_repeat:
000F7Fr 1  AD rr rr     	lda last_cmd	;repeat last command if a, d or i
000F82r 1  8D rr rr     	sta cmd_buf		;fill cmd_buf with <last_cmd_char><nul>
000F85r 1  9C rr rr     	stz cmd_buf+1
000F88r 1  AD rr rr     	lda last_cmd
000F8Br 1  C9 41        	cmp #'A'
000F8Dr 1  F0 20        	beq cmd_decoder
000F8Fr 1  C9 44        	cmp #'D'
000F91r 1  F0 1C        	beq cmd_decoder
000F93r 1  C9 49        	cmp #'I'
000F95r 1  F0 18        	beq cmd_decoder
000F97r 1  C9 59        	cmp #'Y'
000F99r 1  F0 14        	beq cmd_decoder
000F9Br 1  D0 C4        	bne cmd_loopc
000F9Dr 1               ;
000F9Dr 1               ; test non litteral commands #, :
000F9Dr 1               ;
000F9Dr 1               cmd_nolit:
000F9Dr 1  C9 23        	cmp #'#'		;is comment
000F9Fr 1  F0 C0        	beq cmd_loopc
000FA1r 1  C9 3A        	cmp #':'		;is receive hex record
000FA3r 1  D0 04        	bne @1
000FA5r 1  A9 52        	lda #'R'		;change : to R
000FA7r 1  80 06        	bra cmd_decoder
000FA9r 1               @1:
000FA9r 1  C9 3F        	cmp #'?'
000FABr 1  D0 B1        	bne cmd_loop	; unk cmd
000FADr 1  A9 48        	lda #'H'
000FAFr 1               ;
000FAFr 1               ; command decoder
000FAFr 1               ;
000FAFr 1               cmd_decoder:
000FAFr 1  A8           	tay
000FB0r 1  9C rr rr     	stz breakf
000FB3r 1  A9 rr        	lda #>(cmd_loop-1)
000FB5r 1  48           	pha
000FB6r 1  A9 rr        	lda #<(cmd_loop-1)
000FB8r 1  48           	pha
000FB9r 1  98           	tya
000FBAr 1  8D rr rr     	sta last_cmd
000FBDr 1  38           	sec
000FBEr 1  E9 41        	sbc #'A'
000FC0r 1  0A           	asl a
000FC1r 1  AA           	tax
000FC2r 1  BD rr rr     	lda cmd_table+1,x
000FC5r 1  48           	pha
000FC6r 1  BD rr rr     	lda cmd_table,x
000FC9r 1  48           	pha
000FCAr 1               cmd_loop_rts:
000FCAr 1  60           	rts
000FCBr 1               ;
000FCBr 1               ; command address table
000FCBr 1               ;
000FCBr 1               cmd_table:
000FCBr 1  rr rr        	.word cmd_dumpa-1		;a ascii dump
000FCDr 1  rr rr        	.word cmd_cflh-1		;b cf load lba hi
000FCFr 1  rr rr        	.word cmd_modify-1		;c modify memory
000FD1r 1  rr rr        	.word cmd_dump-1		;d dump
000FD3r 1  rr rr        	.word cmd_edit_regs-1	;e edit registers
000FD5r 1  rr rr        	.word cmd_fill-1		;f fill
000FD7r 1  rr rr        	.word cmd_sdlh-1		;g get/set lba 2,3
000FD9r 1  rr rr        	.word cmd_help-1		;h help
000FDBr 1  rr rr        	.word cmd_time-1		;i time
000FDDr 1  rr rr        	.word cmd_jump-1		;j jump
000FDFr 1  rr rr        	.word cmd_empty-1		;k
000FE1r 1  rr rr        	.word cmd_sdl-1			;l load_blocks
000FE3r 1  rr rr        	.word cmd_move-1		;m move
000FE5r 1  rr rr        	.word cmd_pmu-1			;n set/get pmu page
000FE7r 1  rr rr        	.word cmd_boot-1		;o boot from cf
000FE9r 1  rr rr        	.word cmd_print_regs-1	;p print registers
000FEBr 1  rr rr        	.word cmd_at24c-1		;q r/w at24c256
000FEDr 1  rr rr        	.word cmd_rxhex-1		;r rx intel hex record
000FEFr 1  rr rr        	.word cmd_sds-1			;s save_blocks
000FF1r 1  rr rr        	.word cmd_txhex-1		;t tx intel hexime
000FF3r 1  rr rr        	.word cmd_cfl-1			;u load block cf
000FF5r 1  rr rr        	.word cmd_cfs-1			;v save block cf
000FF7r 1  rr rr        	.word cmd_watch-1		;w watch memory
000FF9r 1  rr rr        	.word cmd_memory-1		;x r w or and xor memory
000FFBr 1  rr rr        	.word cmd_sys_timer-1	;y read sys timer
000FFDr 1  rr rr        	.word cmd_sci-1			;z init SD, CF
000FFFr 1               ;
000FFFr 1               ;----------------------------------------------------------
000FFFr 1               ; cmd_help - "H" - print help test
000FFFr 1               ; cmd_empty - empty command
000FFFr 1               ;----------------------------------------------------------
000FFFr 1               ;
000FFFr 1               cmd_help:
000FFFr 1  A9 rr A0 rr  	print_s msg_greetings
001003r 1  20 rr rr     
001006r 1  A9 rr A0 rr  	print_s msg_help
00100Ar 1  20 rr rr     
00100Dr 1               cmd_empty:
00100Dr 1  60           	rts
00100Er 1               ;
00100Er 1               ;----------------------------------------------------------
00100Er 1               ;
00100Er 1               cmd_test:
00100Er 1               ;	jsr tpin_t
00100Er 1               ;	lda #0
00100Er 1  60           	rts
00100Fr 1               
00100Fr 1               	.if 0
00100Fr 1               	mov_n2x help_s, po
00100Fr 1               ;
00100Fr 1               put_s1:
00100Fr 1               	lda (po)
00100Fr 1               	beq @q
00100Fr 1               	jsr acia1_putc
00100Fr 1               	inc_x po
00100Fr 1               	bra put_s1
00100Fr 1               ;
00100Fr 1               @q:
00100Fr 1               	rts
00100Fr 1               test_s:
00100Fr 1               	.res 100,$55
00100Fr 1               	.res 0
00100Fr 1               .ENDIF
00100Fr 1               ;
00100Fr 1               ;----------------------------------------------------------
00100Fr 1               ; pmu - paged memory unit
00100Fr 1               ; N[<page>] - reads sets page
00100Fr 1               ;----------------------------------------------------------
00100Fr 1               ;
00100Fr 1               pmu_init:
00100Fr 1  AD 01 E1     	lda porta0 ; page=0
001012r 1  29 F8        	and #$f8
001014r 1  8D 01 E1     	sta porta0
001017r 1               ;
001017r 1               ; porta[0,1,2] output
001017r 1               ;
001017r 1  AD 03 E1     	lda ddra0
00101Ar 1  29 F8        	and #$f8
00101Cr 1  09 07        	ora #$07
00101Er 1  8D 03 E1     	sta ddra0
001021r 1  60           	rts
001022r 1               ;
001022r 1               ; set page A=n. page 0..7
001022r 1               ;
001022r 1               mpmuw:
001022r 1               pmu_set:
001022r 1  29 07        	and #$07
001024r 1  8D rr rr     	sta chk
001027r 1  AD 01 E1     	lda porta0
00102Ar 1  29 F8        	and #$f8
00102Cr 1  0D rr rr     	ora chk
00102Fr 1  8D 01 E1     	sta porta0
001032r 1  60           	rts
001033r 1               ;
001033r 1               ; get page
001033r 1               ;
001033r 1               mpmur:
001033r 1               pmu_get:
001033r 1  AD 01 E1     	lda porta0
001036r 1  29 07        	and #7
001038r 1  A2 00        	ldx #0
00103Ar 1  60           	rts
00103Br 1               ;
00103Br 1               ; N command
00103Br 1               ;
00103Br 1               cmd_pmu:
00103Br 1  20 rr rr     	jsr scan
00103Er 1  F0 03        	beq @0
001040r 1  20 rr rr     	jsr pmu_set
001043r 1               @0:
001043r 1  AD 01 E1     	lda porta0
001046r 1  29 07        	and #7
001048r 1  20 rr rr     	jsr put_nib_hex
00104Br 1               ;
00104Br 1               no_er:
00104Br 1  20 rr rr     	jsr put_cr_lf
00104Er 1               no_er0:
00104Er 1  A9 00        	lda #ER_NONE
001050r 1  60           	rts
001051r 1               ;
001051r 1               ;----------------------------------------------------------
001051r 1               ; RTC
001051r 1               ;----------------------------------------------------------
001051r 1               ; time - get/set time from rtc
001051r 1               ; if no prameters prints current time
001051r 1               ; else scans input buffer for data
001051r 1               ; "I[hh:mm:ss DD.MM.YYYY]"
001051r 1               ; no test on data validity
001051r 1               ;----------------------------------------------------------
001051r 1               ;
001051r 1               DS3231	:= $d0
001051r 1               ;
001051r 1               cmd_time:
001051r 1  20 rr rr     	jsr scan
001054r 1  D0 49        	bne time_wr
001056r 1               ;
001056r 1               ; print time
001056r 1               ;
001056r 1               time_rd:
001056r 1  20 rr rr     	jsr rtc_read
001059r 1  AD rr rr     	lda hours
00105Cr 1  29 3F        	and #$3f		;clear 12/24 flag
00105Er 1  20 rr rr     	jsr put_c_hex
001061r 1  A9 3A        	lda #':'
001063r 1  20 rr rr     	jsr put_c
001066r 1  AD rr rr     	lda minutes
001069r 1  20 rr rr     	jsr put_c_hex
00106Cr 1  A9 3A        	lda #':'
00106Er 1  20 rr rr     	jsr put_c
001071r 1  AD rr rr     	lda seconds
001074r 1  20 rr rr     	jsr put_c_hex
001077r 1  20 rr rr     	jsr put_sp
00107Ar 1               ;
00107Ar 1               ; print date
00107Ar 1               ;
00107Ar 1  AD rr rr     	lda date
00107Dr 1  20 rr rr     	jsr put_c_hex
001080r 1  A9 2E        	lda #'.'
001082r 1  20 rr rr     	jsr put_c
001085r 1  AD rr rr     	lda month
001088r 1  20 rr rr     	jsr put_c_hex
00108Br 1  A9 2E        	lda #'.'
00108Dr 1  20 rr rr     	jsr put_c
001090r 1  AD rr rr     	lda century
001093r 1  20 rr rr     	jsr put_c_hex
001096r 1  AD rr rr     	lda year
001099r 1  20 rr rr     	jsr put_c_hex
00109Cr 1  4C rr rr     	jmp no_er
00109Fr 1               ;
00109Fr 1               ; set rtc from cmd_buf+1
00109Fr 1               ; no test on values
00109Fr 1               ;
00109Fr 1               time_wr:
00109Fr 1  20 rr rr     	jsr scani      ;discald first ch
0010A2r 1  20 rr rr     	jsr get_b_bcd   ;read h
0010A5r 1  8D rr rr     	sta hours
0010A8r 1  20 rr rr     	jsr scan        ;skip separator
0010ABr 1  20 rr rr     	jsr get_b_bcd   ;m
0010AEr 1  8D rr rr     	sta minutes
0010B1r 1  20 rr rr     	jsr scan
0010B4r 1  20 rr rr     	jsr get_b_bcd   ;s
0010B7r 1  8D rr rr     	sta seconds
0010BAr 1  20 rr rr     	jsr scan
0010BDr 1  20 rr rr     	jsr get_b_bcd   ;date
0010C0r 1  8D rr rr     	sta date
0010C3r 1  20 rr rr     	jsr scan
0010C6r 1  20 rr rr     	jsr get_b_bcd   ;month
0010C9r 1  8D rr rr     	sta month
0010CCr 1  20 rr rr     	jsr scan
0010CFr 1  20 rr rr     	jsr get_b_bcd   ;century
0010D2r 1  8D rr rr     	sta century
0010D5r 1  20 rr rr     	jsr get_b_bcd   ;year
0010D8r 1  8D rr rr     	sta year
0010DBr 1               ;
0010DBr 1  20 rr rr     	jsr rtc_write
0010DEr 1  4C rr rr     	jmp time_rd
0010E1r 1               ;
0010E1r 1               ; reads rtc and puts data in seconds, ....year,century
0010E1r 1               ;
0010E1r 1               mrtcr:
0010E1r 1               rtc_read:
0010E1r 1  20 rr rr     	jsr i2c_init ;idle
0010E4r 1  20 rr rr     	jsr i2c_start
0010E7r 1  A9 D0        	lda #DS3231
0010E9r 1  20 rr rr     	jsr i2c_write
0010ECr 1  D0 05        	bne @0			; if ack continue
0010EEr 1  20 rr rr     	jsr i2c_init	;idle    ; else return
0010F1r 1  38           	sec
0010F2r 1  60           	rts
0010F3r 1               @0:
0010F3r 1  A9 00        	lda #0			; start with reg=0
0010F5r 1  20 rr rr     	jsr i2c_write
0010F8r 1  20 rr rr     	jsr i2c_stop
0010FBr 1  20 rr rr     	jsr i2c_start
0010FEr 1  A9 D1        	lda #DS3231+1
001100r 1  20 rr rr     	jsr i2c_write
001103r 1  20 rr rr     	jsr i2c_read	;s
001106r 1  8D rr rr     	sta seconds
001109r 1  20 rr rr     	jsr i2c_ack
00110Cr 1  20 rr rr     	jsr i2c_read	;min
00110Fr 1  8D rr rr     	sta minutes
001112r 1  20 rr rr     	jsr i2c_ack
001115r 1  20 rr rr     	jsr i2c_read	;h
001118r 1  8D rr rr     	sta hours
00111Br 1  20 rr rr     	jsr i2c_ack
00111Er 1  20 rr rr     	jsr i2c_read	;day of week
001121r 1  8D rr rr     	sta dayweek
001124r 1  20 rr rr     	jsr i2c_ack
001127r 1  20 rr rr     	jsr i2c_read	;date
00112Ar 1  8D rr rr     	sta date
00112Dr 1  20 rr rr     	jsr i2c_ack
001130r 1  20 rr rr     	jsr i2c_read	;month
001133r 1  8D rr rr     	sta month
001136r 1  20 rr rr     	jsr i2c_ack
001139r 1  20 rr rr     	jsr i2c_read	;year
00113Cr 1  8D rr rr     	sta year
00113Fr 1  20 rr rr     	jsr i2c_nack
001142r 1  20 rr rr     	jsr i2c_stop
001145r 1  A2 20        	ldx #$20
001147r 1  8E rr rr     	stx century
00114Ar 1  AD rr rr     	lda month		;clear century bit
00114Dr 1  29 7F        	and #$7f
00114Fr 1  8D rr rr     	sta month
001152r 1  18           	clc
001153r 1  A9 rr        	lda #<seconds   ;return pointer do data
001155r 1  A2 rr        	ldx #>seconds
001157r 1  60           	rts
001158r 1               ;
001158r 1               ; writes rtc regs from seconds,... year,century
001158r 1               ;
001158r 1               mrtcw:
001158r 1               rtc_write:
001158r 1  20 rr rr     	jsr i2c_init	;idle
00115Br 1  20 rr rr     	jsr i2c_start
00115Er 1  A9 D0        	lda #DS3231
001160r 1  20 rr rr     	jsr i2c_write
001163r 1  D0 03        	bne @1			; test for rtc if ok continue
001165r 1  4C rr rr     	jmp i2c_init	;idle    ; else return
001168r 1               ;
001168r 1               @1:
001168r 1  A9 00        	lda #0
00116Ar 1  20 rr rr     	jsr i2c_write
00116Dr 1  AD rr rr     	lda seconds		;s
001170r 1  20 rr rr     	jsr i2c_write
001173r 1  AD rr rr     	lda minutes		;min
001176r 1  20 rr rr     	jsr i2c_write
001179r 1  AD rr rr     	lda hours		;h
00117Cr 1  20 rr rr     	jsr i2c_write
00117Fr 1  AD rr rr     	lda dayweek		;#1 ;week day
001182r 1  20 rr rr     	jsr i2c_write
001185r 1  AD rr rr     	lda date		;d
001188r 1  20 rr rr     	jsr i2c_write
00118Br 1  AD rr rr     	lda month
00118Er 1  20 rr rr     	jsr i2c_write
001191r 1  AD rr rr     	lda year		;y
001194r 1  20 rr rr     	jsr i2c_write
001197r 1  20 rr rr     	jsr i2c_stop
00119Ar 1               ;
00119Ar 1               rtc_init:
00119Ar 1  20 rr rr     	jsr i2c_start	; restart rts ando no sqare wave on int pin
00119Dr 1  A9 D0        	lda #DS3231
00119Fr 1  20 rr rr     	jsr i2c_write
0011A2r 1               	;bne rtc_write_1
0011A2r 1  A9 0E        	lda #$0E
0011A4r 1  20 rr rr     	jsr i2c_write
0011A7r 1  A9 04        	lda #4
0011A9r 1  20 rr rr     	jsr i2c_write
0011ACr 1  A9 00        	lda #0
0011AEr 1  20 rr rr     	jsr i2c_write
0011B1r 1  4C rr rr     	jmp i2c_stop
0011B4r 1               ;
0011B4r 1               ;----------------------------------------------------------
0011B4r 1               ; SDCARD
0011B4r 1               ;----------------------------------------------------------
0011B4r 1               ; sd_read_block_h - G[<lba_h>] reads lba_h and prints lba_h
0011B4r 1               ;----------------------------------------------------------
0011B4r 1               ;
0011B4r 1               cmd_sdlh:
0011B4r 1  20 rr rr     	jsr get_par
0011B7r 1  A9 20 2D rr  	bit_test flags, FLAG_ADD
0011BBr 1  rr           
0011BCr 1  D0 0C        	bne @1
0011BEr 1               @0:
0011BEr 1  AD rr rr     	lda sd_lba+2
0011C1r 1  AC rr rr     	ldy sd_lba+3
0011C4r 1  20 rr rr     	jsr put_w_hex
0011C7r 1  4C rr rr     	jmp no_er
0011CAr 1               @1:
0011CAr 1  A5 rr A6 rr  	mov_x2ax add
0011CEr 1  20 rr rr     	jsr sd_set_sector_h
0011D1r 1  80 EB        	bra @0
0011D3r 1               ;
0011D3r 1               ;----------------------------------------------------------
0011D3r 1               ; save_blocks - "S<start_block_l>,<num_of_blocks>,<addr>"
0011D3r 1               ; save memory to sd card
0011D3r 1               ;----------------------------------------------------------
0011D3r 1               ;
0011D3r 1               cmd_sds:
0011D3r 1  20 rr rr     	jsr get_par
0011D6r 1  A2 rr 20 rr  	test_x len
0011DAr 1  rr           
0011DBr 1  F0 2A        	beq @e
0011DDr 1               @l:
0011DDr 1  A5 rr A6 rr  	mov_x2ax add			;block num
0011E1r 1  20 rr rr     	jsr sd_set_sector_l
0011E4r 1  A5 rr A6 rr  	mov_x2ax data			;buf add
0011E8r 1  20 rr rr     	jsr sd_write_sector
0011EBr 1  C9 00        	cmp #0
0011EDr 1  D0 1A        	bne @q
0011EFr 1  A9 2E 20 rr  	print_c '.'
0011F3r 1  rr           
0011F4r 1  E6 rr        	inc data+1
0011F6r 1  E6 rr        	inc data+1
0011F8r 1  A2 rr 20 rr  	inc_x add			;block num ++
0011FCr 1  rr           
0011FDr 1  A2 rr 20 rr  	dec_x len			;num blocks --
001201r 1  rr           
001202r 1  D0 D9        	bne @l
001204r 1  4C rr rr     	jmp no_er
001207r 1               @e:
001207r 1  A9 01        	lda #ER_LEN
001209r 1               @q:
001209r 1  4C rr rr     	jmp put_cr_lf
00120Cr 1               ;
00120Cr 1               ;----------------------------------------------------------
00120Cr 1               ; load_blocks - L<start_block>,<num_of_blocks>,<addr>"
00120Cr 1               ; load data from sd card to memory start_block=0..
00120Cr 1               ;----------------------------------------------------------
00120Cr 1               cmd_sdl:
00120Cr 1  20 rr rr     	jsr get_par
00120Fr 1  A2 rr 20 rr  	test_x len
001213r 1  rr           
001214r 1  F0 2A        	beq cmd_sdle
001216r 1               cmd_sdll:
001216r 1  A5 rr A6 rr  	mov_x2ax add            ;block num
00121Ar 1  20 rr rr     	jsr sd_set_sector_l
00121Dr 1  A5 rr A6 rr  	mov_x2ax data           ;buf add
001221r 1  20 rr rr     	jsr sd_read_sector
001224r 1  C9 00        	cmp #0
001226r 1  D0 1A        	bne cmd_sdlq
001228r 1  A9 2E 20 rr  	print_c '.'
00122Cr 1  rr           
00122Dr 1  E6 rr        	inc data+1
00122Fr 1  E6 rr        	inc data+1
001231r 1  A2 rr 20 rr  	inc_x add        ; block num ++
001235r 1  rr           
001236r 1  A2 rr 20 rr  	dec_x len        ; num blocks --
00123Ar 1  rr           
00123Br 1  D0 D9        	bne cmd_sdll
00123Dr 1  4C rr rr     	jmp no_er
001240r 1               cmd_sdle:
001240r 1  A9 01        	lda #ER_LEN
001242r 1               cmd_sdlq:
001242r 1  4C rr rr     	jmp put_cr_lf
001245r 1               ;
001245r 1               ;----------------------------------------------------------
001245r 1               ; CF - COMPACT FLASH
001245r 1               ;----------------------------------------------------------
001245r 1               ; cmd_cflh cf read lba hi
001245r 1               ; G[<lba_h>] reads lba_h and prints full lba
001245r 1               ;----------------------------------------------------------
001245r 1               ;
001245r 1               cmd_cflh:
001245r 1  20 rr rr     	jsr get_par
001248r 1  A9 20 2D rr  	bit_test flags, FLAG_ADD
00124Cr 1  rr           
00124Dr 1  D0 0C        	bne @1
00124Fr 1               @0:
00124Fr 1  AD rr rr     	lda cf_lba+2
001252r 1  AC rr rr     	ldy cf_lba+3
001255r 1  20 rr rr     	jsr put_w_hex
001258r 1  4C rr rr     	jmp no_er
00125Br 1               @1:
00125Br 1  A5 rr A6 rr  	mov_x2ax add
00125Fr 1  20 rr rr     	jsr cf_set_sector_h
001262r 1  80 EB        	bra @0
001264r 1               ;
001264r 1               ;----------------------------------------------------------
001264r 1               ; cmd_cfs - "V<start_block_l>,<number_of_blocks>,<address>"
001264r 1               ; save memory to cf card
001264r 1               ;----------------------------------------------------------
001264r 1               ;
001264r 1               cmd_cfs:
001264r 1  20 rr rr     	jsr get_par
001267r 1  A2 rr 20 rr  	test_x len
00126Br 1  rr           
00126Cr 1  F0 2A        	beq @e
00126Er 1               @l:
00126Er 1  A5 rr A6 rr  	mov_x2ax add        ;block num
001272r 1  20 rr rr     	jsr cf_set_sector_l
001275r 1  A5 rr A6 rr  	mov_x2ax data       ;buf add
001279r 1  20 rr rr     	jsr cf_wrs
00127Cr 1  C9 00        	cmp #0
00127Er 1  D0 1A        	bne @q
001280r 1  A9 2E 20 rr  	print_c '.'
001284r 1  rr           
001285r 1  E6 rr        	inc data+1
001287r 1  E6 rr        	inc data+1
001289r 1  A2 rr 20 rr  	inc_x add           ;block num ++
00128Dr 1  rr           
00128Er 1  A2 rr 20 rr  	dec_x len           ;num blocks --
001292r 1  rr           
001293r 1  D0 D9        	bne @l
001295r 1  4C rr rr     	jmp no_er
001298r 1               @e:
001298r 1  A9 01        	lda #ER_LEN
00129Ar 1               @q:
00129Ar 1  4C rr rr     	jmp put_cr_lf
00129Dr 1               ;
00129Dr 1               ;----------------------------------------------------------
00129Dr 1               ; cmd_cfl -  "U<start_block>,<number_of_blocks>,<address>"
00129Dr 1               ; load data from cf card to memory start_block=0..
00129Dr 1               ;----------------------------------------------------------
00129Dr 1               ;
00129Dr 1               cmd_cfl:
00129Dr 1  20 rr rr     	jsr get_par
0012A0r 1  A2 rr 20 rr  	test_x len
0012A4r 1  rr           
0012A5r 1  F0 2A        	beq cmd_cfle
0012A7r 1               cmd_cfll:
0012A7r 1  A5 rr A6 rr  	mov_x2ax add		; block num
0012ABr 1  20 rr rr     	jsr cf_set_sector_l
0012AEr 1  A5 rr A6 rr  	mov_x2ax data		; buf add
0012B2r 1  20 rr rr     	jsr cf_rds
0012B5r 1  C9 00        	cmp #0
0012B7r 1  D0 1A        	bne cmd_cflq
0012B9r 1  A9 2E 20 rr  	print_c '.'
0012BDr 1  rr           
0012BEr 1  E6 rr        	inc data+1
0012C0r 1  E6 rr        	inc data+1
0012C2r 1  A2 rr 20 rr  	inc_x add			; block num ++
0012C6r 1  rr           
0012C7r 1  A2 rr 20 rr  	dec_x len			; num blocks --
0012CBr 1  rr           
0012CCr 1  D0 D9        	bne cmd_cfll
0012CEr 1  4C rr rr     	jmp no_er
0012D1r 1               cmd_cfle:
0012D1r 1  A9 01        	lda #ER_LEN
0012D3r 1               cmd_cflq:
0012D3r 1  4C rr rr     	jmp put_cr_lf
0012D6r 1               ;
0012D6r 1               ; cmd_cfboot
0012D6r 1               ; O or O0 boot CF
0012D6r 1               ; O1      boot SD
0012D6r 1               ;
0012D6r 1               boot_ad	:= $d000	;sim start
0012D6r 1               load_ad	:= $ba00	;ccm start
0012D6r 1               msg_boot:
0012D6r 1  42 6F 6F 74  	.byte "Booting...", 0
0012DAr 1  69 6E 67 2E  
0012DEr 1  2E 2E 00     
0012E1r 1               ;
0012E1r 1               cmd_boot:
0012E1r 1  20 rr rr     	jsr get_par
0012E4r 1  A9 rr A0 rr  	print_s msg_boot
0012E8r 1  20 rr rr     
0012EBr 1  A9 20 2D rr  	bit_test flags, FLAG_ADD
0012EFr 1  rr           
0012F0r 1  F0 08        	beq @cf
0012F2r 1  A5 rr        	lda add
0012F4r 1  29 01        	and #1
0012F6r 1  F0 02        	beq @cf
0012F8r 1  D0 21        	bne @sd
0012FAr 1               @cf:
0012FAr 1  A9 11 A0 00  	mov_n2x $11, len	; n of lba's
0012FEr 1  85 rr 84 rr  
001302r 1  A9 00 A0 00  	mov_n2x 0, add	; start lba in cf
001306r 1  85 rr 84 rr  
00130Ar 1  A9 00 A0 BA  	mov_n2x load_ad, data	;load address
00130Er 1  85 rr 84 rr  
001312r 1  20 rr rr     	jsr cmd_cfll
001315r 1               @c:
001315r 1  F0 01        	beq @b
001317r 1  60           	rts
001318r 1               @b:
001318r 1  4C 00 D0     	jmp boot_ad
00131Br 1               @sd:
00131Br 1  A9 11 A0 00  	mov_n2x $11, len	; n of lba's
00131Fr 1  85 rr 84 rr  
001323r 1  A9 00 A0 00  	mov_n2x 0, add	; start lba in cf
001327r 1  85 rr 84 rr  
00132Br 1  A9 00 A0 BA  	mov_n2x load_ad, data	;load address
00132Fr 1  85 rr 84 rr  
001333r 1  20 rr rr     	jsr cmd_sdll
001336r 1  80 DD        	bra @c
001338r 1               ;
001338r 1               ; warm boot CF
001338r 1               ;
001338r 1               mbtcfw:
001338r 1  A9 0B A0 00  	mov_n2x 11, len	;ccm+pem
00133Cr 1  85 rr 84 rr  
001340r 1  A9 00 A0 00  	mov_n2x 0, add
001344r 1  85 rr 84 rr  
001348r 1  A9 00 A0 BA  	mov_n2x load_ad, data
00134Cr 1  85 rr 84 rr  
001350r 1  4C rr rr     	jmp cmd_cfll
001353r 1               ;
001353r 1               ; warm boot SD
001353r 1               ;
001353r 1               mbtsdw:
001353r 1  A9 0B A0 00  	mov_n2x 11, len	;ccm+pem
001357r 1  85 rr 84 rr  
00135Br 1  A9 00 A0 00  	mov_n2x 0, add
00135Fr 1  85 rr 84 rr  
001363r 1  A9 00 A0 BA  	mov_n2x load_ad, data
001367r 1  85 rr 84 rr  
00136Br 1  4C rr rr     	jmp cmd_sdll
00136Er 1               ;
00136Er 1               ;----------------------------------------------------------
00136Er 1               ; cmd_sci - init sd|cf ; Z | Z0 - init cf,  Z1 - init sd
00136Er 1               ;----------------------------------------------------------
00136Er 1               ;
00136Er 1               cmd_sci:
00136Er 1  20 rr rr     	jsr get_par
001371r 1  A9 20 2D rr  	bit_test flags, FLAG_ADD
001375r 1  rr           
001376r 1  F0 0B        	beq @e
001378r 1  A5 rr        	lda add
00137Ar 1  29 01        	and #1
00137Cr 1  F0 05        	beq @e
00137Er 1  20 rr rr     	jsr sd_init
001381r 1  80 03        	bra @q
001383r 1               @e:
001383r 1  20 rr rr     	jsr cf_init
001386r 1               @q:
001386r 1  4C rr rr     	jmp put_cr_lf
001389r 1               ;
001389r 1               ;----------------------------------------------------------
001389r 1               ; cmd_memory - read write memory
001389r 1               ; "X<memory_add>,<data>,<mode>"
001389r 1               ; <mode>=0 for write, 1 for or, 2 for and, 3 for xor
001389r 1               ; <mode>=1 (mem_add)=(mem_add) | & ^ data
001389r 1               ;----------------------------------------------------------
001389r 1               ;
001389r 1               cmd_memory:
001389r 1  20 rr rr     	jsr get_par
00138Cr 1  A5 rr        	lda data
00138Er 1  29 03        	and #$03        ; only 2 bits
001390r 1  F0 20        	beq @0
001392r 1  C9 01        	cmp #1
001394r 1  F0 14        	beq @1
001396r 1  C9 02        	cmp #2
001398r 1  F0 08        	beq @2
00139Ar 1               @3:
00139Ar 1  B2 rr        	lda (add)	; read, xor, write
00139Cr 1  45 rr        	eor len
00139Er 1  92 rr        	sta (add)
0013A0r 1  80 14        	bra @q
0013A2r 1               @2:
0013A2r 1  B2 rr        	lda (add)	;read. and, write
0013A4r 1  25 rr        	and len
0013A6r 1  92 rr        	sta (add)
0013A8r 1  80 0C        	bra @q
0013AAr 1               @1:
0013AAr 1  B2 rr        	lda (add)	; read, or, write
0013ACr 1  05 rr        	ora len
0013AEr 1  92 rr        	sta (add)
0013B0r 1  80 04        	bra @q
0013B2r 1               @0:
0013B2r 1  A5 rr        	lda len		; write
0013B4r 1  92 rr        	sta (add)
0013B6r 1               @q:
0013B6r 1  A9 00        	lda #0
0013B8r 1  60           	rts
0013B9r 1               ;
0013B9r 1               ;----------------------------------------------------------
0013B9r 1               ; put_c_bin - print_regs
0013B9r 1               ;----------------------------------------------------------
0013B9r 1               ; print a in binary
0013B9r 1               ;
0013B9r 1               put_c_bin:
0013B9r 1  A0 08        	ldy #8
0013BBr 1               @0:
0013BBr 1  2A           	rol a
0013BCr 1  AA           	tax
0013BDr 1  A9 30        	lda #'0'
0013BFr 1  90 02        	bcc @1
0013C1r 1  69 00        	adc #0
0013C3r 1               @1:
0013C3r 1  20 rr rr     	jsr put_c
0013C6r 1  8A           	txa
0013C7r 1  88           	dey
0013C8r 1  D0 F1        	bne @0
0013CAr 1  60           	rts
0013CBr 1               ;
0013CBr 1  20 20 20 41  t_a:	.byte "   A:", 0
0013CFr 1  3A 00        
0013D1r 1  20 20 20 58  t_x:	.byte "   X:", 0
0013D5r 1  3A 00        
0013D7r 1  20 20 20 59  t_y:	.byte "   Y:", 0
0013DBr 1  3A 00        
0013DDr 1  20 20 53 50  t_sp:	.byte "  SP:", 0
0013E1r 1  3A 00        
0013E3r 1  20 20 43 43  t_cc:	.byte "  CC:", 0
0013E7r 1  3A 00        
0013E9r 1  20 20 50 43  t_pc:	.byte "  PC:", 0
0013EDr 1  3A 00        
0013EFr 1  20 20 20 20  t_sf:	.byte "     NV-BDIZC", CR, LF, 0
0013F3r 1  20 4E 56 2D  
0013F7r 1  42 44 49 5A  
0013FFr 1               ;
0013FFr 1               cmd_print_regs:
0013FFr 1  A9 rr A0 rr  	print_s t_sf
001403r 1  20 rr rr     
001406r 1  A9 rr A0 rr  	print_s t_cc
00140Ar 1  20 rr rr     
00140Dr 1  AD rr rr     	lda reg_cc
001410r 1  20 rr rr     	jsr put_c_bin
001413r 1  A9 rr A0 rr  	print_s t_a
001417r 1  20 rr rr     
00141Ar 1  AD rr rr     	lda reg_a
00141Dr 1  20 rr rr     	jsr put_c_hex
001420r 1  A9 rr A0 rr  	print_s t_x
001424r 1  20 rr rr     
001427r 1  AD rr rr     	lda reg_x
00142Ar 1  20 rr rr     	jsr put_c_hex
00142Dr 1  A9 rr A0 rr  	print_s t_y
001431r 1  20 rr rr     
001434r 1  AD rr rr     	lda reg_y
001437r 1  20 rr rr     	jsr put_c_hex
00143Ar 1  A9 rr A0 rr  	print_s t_sp
00143Er 1  20 rr rr     
001441r 1  AD rr rr     	lda reg_sp
001444r 1  20 rr rr     	jsr put_c_hex
001447r 1  A9 rr A0 rr  	print_s t_pc
00144Br 1  20 rr rr     
00144Er 1  AD rr rr AC  	mov_x2ay reg_pc
001452r 1  rr rr        
001454r 1  20 rr rr     	jsr put_w_hex
001457r 1  4C rr rr     	jmp no_er
00145Ar 1               ;
00145Ar 1               ;----------------------------------------------------------
00145Ar 1               ; cmd_edit_regs - change/edit regs "E"
00145Ar 1               ;----------------------------------------------------------
00145Ar 1               ; a
00145Ar 1               cmd_edit_regs:
00145Ar 1  A9 rr A0 rr  	print_s t_a
00145Er 1  20 rr rr     
001461r 1  AD rr rr     	lda reg_a
001464r 1  20 rr rr     	jsr edit_regs_c
001467r 1  B0 03        	bcs @x
001469r 1  8D rr rr     	sta reg_a
00146Cr 1               @x:
00146Cr 1  A9 rr A0 rr  	print_s t_x
001470r 1  20 rr rr     
001473r 1  AD rr rr     	lda reg_x
001476r 1  20 rr rr     	jsr edit_regs_c
001479r 1  B0 03        	bcs @y
00147Br 1  8D rr rr     	sta reg_x
00147Er 1               @y:
00147Er 1  A9 rr A0 rr  	print_s t_y
001482r 1  20 rr rr     
001485r 1  AD rr rr     	lda reg_y
001488r 1  20 rr rr     	jsr edit_regs_c
00148Br 1  B0 03        	bcs @sp
00148Dr 1  8D rr rr     	sta reg_y
001490r 1               @sp:
001490r 1  A9 rr A0 rr  	print_s t_sp
001494r 1  20 rr rr     
001497r 1  AD rr rr     	lda reg_sp
00149Ar 1  20 rr rr     	jsr edit_regs_c
00149Dr 1  B0 03        	bcs @cc
00149Fr 1  8D rr rr     	sta reg_sp
0014A2r 1               @cc:
0014A2r 1  A9 rr A0 rr  	print_s t_cc
0014A6r 1  20 rr rr     
0014A9r 1  AD rr rr     	lda reg_cc
0014ACr 1  20 rr rr     	jsr edit_regs_c
0014AFr 1  B0 03        	bcs @pc
0014B1r 1  8D rr rr     	sta reg_cc
0014B4r 1               @pc:
0014B4r 1  A9 rr A0 rr  	print_s t_pc
0014B8r 1  20 rr rr     
0014BBr 1  AD rr rr AC  	mov_x2ay reg_pc
0014BFr 1  rr rr        
0014C1r 1  20 rr rr     	jsr put_w_hex
0014C4r 1  20 rr rr     	jsr edit_regs_c1
0014C7r 1  B0 06        	bcs @q
0014C9r 1  8D rr rr     	sta reg_pc
0014CCr 1  8C rr rr     	sty reg_pc+1
0014CFr 1               @q:
0014CFr 1  A9 00        	lda #0
0014D1r 1  60           	rts
0014D2r 1               ;
0014D2r 1               edit_regs_c:
0014D2r 1  20 rr rr     	jsr put_c_hex
0014D5r 1               edit_regs_c1:
0014D5r 1  20 rr rr     	jsr put_sp
0014D8r 1  20 rr rr     	jsr get_s
0014DBr 1  90 05        	bcc @0
0014DDr 1  68           	pla			; CTRL-X
0014DEr 1  68           	pla
0014DFr 1  A9 00        	lda #0
0014E1r 1  60           	rts
0014E2r 1               @0:
0014E2r 1  A0 FF        	ldy #$ff
0014E4r 1  8C rr rr     	sty scany
0014E7r 1  20 rr rr     	jsr get_par
0014EAr 1  A9 20 2D rr  	bit_test flags, FLAG_ADD
0014EEr 1  rr           
0014EFr 1  D0 02        	bne @q
0014F1r 1  38           	sec
0014F2r 1  60           	rts
0014F3r 1               @q:
0014F3r 1  A5 rr        	lda add		;add entered
0014F5r 1  A4 rr        	ldy add+1
0014F7r 1  18           	clc
0014F8r 1  60           	rts
0014F9r 1               ;
0014F9r 1               ;----------------------------------------------------------
0014F9r 1               ; cmd_jump - jump @add if add present else jump @reg_pc
0014F9r 1               ;----------------------------------------------------------
0014F9r 1               ;
0014F9r 1               cmd_jump:
0014F9r 1  20 rr rr     	jsr get_par
0014FCr 1  A9 20 2D rr  	bit_test flags, FLAG_ADD
001500r 1  rr           
001501r 1  F0 0A        	beq @0
001503r 1  A5 rr A4 rr  	mov_x2y add, reg_pc
001507r 1  8D rr rr 8C  
00150Br 1  rr rr        
00150Dr 1               @0:
00150Dr 1  4C rr rr     	jmp run_target
001510r 1               ;
001510r 1               ;----------------------------------------------------------
001510r 1               ; cmd_watch - watch memory location
001510r 1               ;----------------------------------------------------------
001510r 1               ;
001510r 1               cmd_watch:
001510r 1  20 rr rr     	jsr get_par
001513r 1  A5 rr A4 rr  	mov_x2y add, ra
001517r 1  85 rr 84 rr  
00151Br 1  A5 rr A4 rr  	print_w_hex ra
00151Fr 1  20 rr rr     
001522r 1  A9 3A 20 rr  	print_c ':'
001526r 1  rr           
001527r 1  20 rr rr     	print_sp
00152Ar 1               @1:
00152Ar 1  A0 00        	ldy #0
00152Cr 1  B1 rr        	lda (ra),y
00152Er 1  20 rr rr     	jsr put_c_hex
001531r 1  20 rr rr     	jsr tbreak
001534r 1  90 03        	bcc @2
001536r 1  4C rr rr     	jmp no_er
001539r 1               @2:
001539r 1  A0 64        	ldy #100	;50ms
00153Br 1  20 rr rr     	jsr delayhalfms
00153Er 1  A9 08 20 rr  	print_c BS
001542r 1  rr           
001543r 1  A9 08 20 rr  	print_c BS
001547r 1  rr           
001548r 1  80 E0        	bra @1
00154Ar 1               ;
00154Ar 1               ;----------------------------------------------------------
00154Ar 1               ; cmd_rxhex - rx intel hex file & store data in mem
00154Ar 1               ;----------------------------------------------------------
00154Ar 1               ; parse line ":LLAAAATTDDDDDDD...DDDCC"
00154Ar 1               ;
00154Ar 1               cmd_rxhex:
00154Ar 1  A9 00        	lda #0		;chk<=0
00154Cr 1  8D rr rr     	sta chk
00154Fr 1  20 rr rr     	jsr scani
001552r 1  C9 3A        	cmp #':'          ;: start
001554r 1  D0 4F        	bne @er
001556r 1  20 rr rr     	jsr get_c_hex_chk ;rec len
001559r 1  B0 4A        	bcs @er
00155Br 1  85 rr        	sta len
00155Dr 1  F0 43        	beq @20		; if len==0 empty record
00155Fr 1  20 rr rr     	jsr get_c_hex_chk	;adh
001562r 1  B0 41        	bcs @er
001564r 1  85 rr        	sta ra+1
001566r 1  20 rr rr     	jsr get_c_hex_chk ;adl
001569r 1  B0 3A        	bcs @er
00156Br 1  85 rr        	sta ra
00156Dr 1  20 rr rr     	jsr get_c_hex_chk	;rec type
001570r 1  B0 33        	bcs @er
001572r 1  C9 00        	cmp #0
001574r 1  D0 2F        	bne @er
001576r 1  A5 rr        	lda len
001578r 1  8D rr rr     	sta count
00157Br 1               @1:
00157Br 1  20 rr rr     	jsr get_c_hex_chk
00157Er 1  B0 25        	bcs @er
001580r 1  CE rr rr     	dec count
001583r 1  D0 F6        	bne @1
001585r 1               ;
001585r 1               ; read txed chk and add, sum must be 0
001585r 1               ;
001585r 1  20 rr rr     	jsr get_c_hex_chk
001588r 1  B0 1B        	bcs @er
00158Ar 1  AD rr rr     	lda chk
00158Dr 1  D0 16        	bne @er
00158Fr 1               ;
00158Fr 1               ; read data and store
00158Fr 1               ;
00158Fr 1  A9 08        	lda #8		; read only data from 9
001591r 1  8D rr rr     	sta scany
001594r 1               @2:
001594r 1  20 rr rr     	jsr get_c_hex
001597r 1  92 rr        	sta (ra)
001599r 1  A2 rr 20 rr  	inc_x ra
00159Dr 1  rr           
00159Er 1  C6 rr        	dec len		;count ;dex
0015A0r 1  D0 F2        	bne @2
0015A2r 1               @20:
0015A2r 1  4C rr rr     	jmp no_er0
0015A5r 1               @er:
0015A5r 1  A9 30        	lda #$30
0015A7r 1  4C rr rr     	jmp is_er
0015AAr 1               ;
0015AAr 1               ;----------------------------------------------------------
0015AAr 1               ; get_c_hex_chk - read hex byte & chk+=b
0015AAr 1               ;----------------------------------------------------------
0015AAr 1               ;
0015AAr 1               get_c_hex_chk:
0015AAr 1  20 rr rr     	jsr get_c_hex
0015ADr 1  B0 04        	bcs @q
0015AFr 1  20 rr rr     	jsr add_chk
0015B2r 1  18           	clc
0015B3r 1               @q:
0015B3r 1  60           	rts
0015B4r 1               ;
0015B4r 1               ;----------------------------------------------------------
0015B4r 1               ; cmp_s - compare string in (ay) to (po)
0015B4r 1               ;----------------------------------------------------------
0015B4r 1               ;
0015B4r 1               cmp_s:
0015B4r 1  85 rr        	sta ra
0015B6r 1  84 rr        	sty ra+1
0015B8r 1  A0 00        	ldy #0
0015BAr 1               @0:
0015BAr 1  B1 rr        	lda (po),y
0015BCr 1  F0 07        	beq @q
0015BEr 1  D1 rr        	cmp (ra),y
0015C0r 1  D0 03        	bne @q
0015C2r 1  C8           	iny
0015C3r 1  80 F5        	bra @0
0015C5r 1               @q:
0015C5r 1  60           	rts
0015C6r 1               ;
0015C6r 1               ;----------------------------------------------------------
0015C6r 1               ; cmd_txhex - transmitt block in intel hex
0015C6r 1               ;----------------------------------------------------------
0015C6r 1               ;
0015C6r 1               cmd_txhex:
0015C6r 1  20 rr rr     	jsr get_par
0015C9r 1  A2 rr 20 rr  	test_x len
0015CDr 1  rr           
0015CEr 1  D0 01        	bne @00
0015D0r 1  60           	rts
0015D1r 1               @00:
0015D1r 1  A5 rr A4 rr  	mov_x2y len, ra
0015D5r 1  85 rr 84 rr  
0015D9r 1  A5 rr A4 rr  	mov_x2y add, rc
0015DDr 1  85 rr 84 rr  
0015E1r 1  A9 10 A0 00  	mov_n2x 16, rb
0015E5r 1  85 rr 84 rr  
0015E9r 1               @0:
0015E9r 1  20 rr rr     	jsr cmp_ra2rb
0015ECr 1  90 0A        	bcc @1			;len<16
0015EEr 1  A9 10        	lda #16
0015F0r 1  8D rr rr     	sta count
0015F3r 1  20 rr rr     	jsr sub_rb2ra
0015F6r 1  80 07        	bra @2
0015F8r 1               @1:
0015F8r 1  A5 rr        	lda ra
0015FAr 1  8D rr rr     	sta count
0015FDr 1  64 rr        	stz ra
0015FFr 1               @2:
0015FFr 1  A9 3A 20 rr  	print_c ':'
001603r 1  rr           
001604r 1  9C rr rr     	stz chk
001607r 1  AD rr rr     	lda count
00160Ar 1  20 rr rr     	jsr put_c_hex_chk	;ckh+=len
00160Dr 1  A5 rr        	lda rc+1			;chk+=ad chk+=ad+1 print add
00160Fr 1  20 rr rr     	jsr put_c_hex_chk
001612r 1  A5 rr        	lda rc
001614r 1  20 rr rr     	jsr put_c_hex_chk
001617r 1  A9 00        	lda #0				;record type=00
001619r 1  20 rr rr     	jsr put_c_hex_chk
00161Cr 1               @3:
00161Cr 1  B2 rr        	lda (rc)
00161Er 1  20 rr rr     	jsr put_c_hex_chk
001621r 1  A2 rr 20 rr  	inc_x rc
001625r 1  rr           
001626r 1  CE rr rr     	dec count
001629r 1  D0 F1        	bne @3
00162Br 1  AD rr rr     	lda chk
00162Er 1  20 rr rr     	jsr two_complement
001631r 1  20 rr rr     	jsr put_c_hex
001634r 1  20 rr rr     	jsr put_cr_lf
001637r 1  A2 rr 20 rr  	test_x ra
00163Br 1  rr           
00163Cr 1  D0 AB        	bne @0			;continue
00163Er 1               ; last record
00163Er 1               lastrec:
00163Er 1  A9 rr A0 rr  	mov_n2ay msg_hex_end_record
001642r 1  20 rr rr     	jsr put_s
001645r 1  4C rr rr     	jmp no_er
001648r 1               ;
001648r 1               ;----------------------------------------------------------
001648r 1               ; put_c_hex_chk - print hex char & chk+=acc
001648r 1               ;----------------------------------------------------------
001648r 1               ;
001648r 1               put_c_hex_chk:
001648r 1  20 rr rr     	jsr add_chk
00164Br 1  4C rr rr     	jmp put_c_hex
00164Er 1               ;
00164Er 1               ;----------------------------------------------------------
00164Er 1               ; add_chk -  chk+=acc
00164Er 1               ;----------------------------------------------------------
00164Er 1               ;
00164Er 1               add_chk:
00164Er 1  48           	pha
00164Fr 1  18           	clc
001650r 1  6D rr rr     	adc chk
001653r 1  8D rr rr     	sta chk
001656r 1  68           	pla
001657r 1  60           	rts
001658r 1               ;
001658r 1               two_complement:
001658r 1  49 FF        	eor #$ff
00165Ar 1  18           	clc
00165Br 1  69 01        	adc #1
00165Dr 1  60           	rts
00165Er 1               ;
00165Er 1               ;----------------------------------------------------------
00165Er 1               ; move - move block of data source, length, destination
00165Er 1               ;----------------------------------------------------------
00165Er 1               ;
00165Er 1               src		= add
00165Er 1               dst		= data
00165Er 1               ;
00165Er 1               cmd_move:
00165Er 1  20 rr rr     	jsr get_par
001661r 1  A2 rr 20 rr  	test_x len
001665r 1  rr           
001666r 1  F0 66        	beq @dnq
001668r 1               ;	lda #$ff
001668r 1               ;	sta count
001668r 1  A5 rr A4 rr  	mov_x2y dst, ra
00166Cr 1  85 rr 84 rr  
001670r 1  A5 rr A4 rr  	mov_x2y src, rb
001674r 1  85 rr 84 rr  
001678r 1  20 rr rr     	jsr cmp_ra2rb
00167Br 1  B0 02        	bcs @0
00167Dr 1  90 18        	bcc @dn
00167Fr 1               @0:
00167Fr 1  A5 rr A4 rr  	mov_x2y len, ra
001683r 1  85 rr 84 rr  
001687r 1  20 rr rr     	jsr add_rb2ra
00168Ar 1  A5 rr A4 rr  	mov_x2y dst, rb
00168Er 1  85 rr 84 rr  
001692r 1  20 rr rr     	jsr cmp_ra2rb
001695r 1  B0 3A        	bcs @up
001697r 1               @dn:
001697r 1  A5 rr A4 rr  	mov_x2y src, ra   ; move data from begin
00169Br 1  85 rr 84 rr  
00169Fr 1  A5 rr A4 rr  	mov_x2y dst, rb
0016A3r 1  85 rr 84 rr  
0016A7r 1  A5 rr A4 rr  	mov_x2y len, rc
0016ABr 1  85 rr 84 rr  
0016AFr 1  A0 FF        	ldy #255
0016B1r 1               @dn0:
0016B1r 1  B2 rr        	lda (ra)
0016B3r 1  92 rr        	sta (rb)
0016B5r 1               	;;inc count
0016B5r 1  C8           	iny
0016B6r 1  D0 05        	bne @dn1
0016B8r 1  A9 2E 20 rr  	print_c '.'
0016BCr 1  rr           
0016BDr 1               @dn1:
0016BDr 1  A2 rr 20 rr  	inc_x ra
0016C1r 1  rr           
0016C2r 1  A2 rr 20 rr  	inc_x rb
0016C6r 1  rr           
0016C7r 1  A2 rr 20 rr  	dec_x rc
0016CBr 1  rr           
0016CCr 1  D0 E3        	bne @dn0
0016CEr 1               @dnq:
0016CEr 1  4C rr rr     	jmp no_er
0016D1r 1               ;
0016D1r 1               @up:
0016D1r 1  A5 rr A4 rr  	mov_x2y src, ra ; move data from end
0016D5r 1  85 rr 84 rr  
0016D9r 1  A5 rr A4 rr  	mov_x2y len, rb
0016DDr 1  85 rr 84 rr  
0016E1r 1  20 rr rr     	jsr add_rb2ra
0016E4r 1  A5 rr A4 rr  	mov_x2y ra, po ;src
0016E8r 1  85 rr 84 rr  
0016ECr 1  A5 rr A4 rr  	mov_x2y dst, ra
0016F0r 1  85 rr 84 rr  
0016F4r 1  20 rr rr     	jsr add_rb2ra  ;dst+l->ra
0016F7r 1  A5 rr A4 rr  	mov_x2y po, rb ;src+l->rb
0016FBr 1  85 rr 84 rr  
0016FFr 1  A5 rr A4 rr  	mov_x2y len, rc ;l->rc
001703r 1  85 rr 84 rr  
001707r 1  A2 rr 20 rr  	dec_x ra
00170Br 1  rr           
00170Cr 1  A2 rr 20 rr  	dec_x rb
001710r 1  rr           
001711r 1  A0 FF        	ldy #255
001713r 1               @up0:
001713r 1  B2 rr        	lda (rb)
001715r 1  92 rr        	sta (ra)
001717r 1               	;inc count
001717r 1  C8           	iny
001718r 1  D0 05        	bne @up1
00171Ar 1  A9 2E 20 rr  	print_c '.'
00171Er 1  rr           
00171Fr 1               @up1:
00171Fr 1  A2 rr 20 rr  	dec_x ra
001723r 1  rr           
001724r 1  A2 rr 20 rr  	dec_x rb
001728r 1  rr           
001729r 1  A2 rr 20 rr  	dec_x rc
00172Dr 1  rr           
00172Er 1  D0 E3        	bne @up0
001730r 1  4C rr rr     	jmp no_er
001733r 1               ;
001733r 1               ;----------------------------------------------------------
001733r 1               ; cmd_modify - modify memory @ address
001733r 1               ;----------------------------------------------------------
001733r 1               ;
001733r 1               cmd_modify:
001733r 1  20 rr rr     	jsr get_par
001736r 1  A5 rr A4 rr  	mov_x2y add, rc
00173Ar 1  85 rr 84 rr  
00173Er 1               @0:
00173Er 1  A5 rr A4 rr  	print_w_hex rc
001742r 1  20 rr rr     
001745r 1  A9 3A 20 rr  	print_c ':'
001749r 1  rr           
00174Ar 1  20 rr rr     	print_sp
00174Dr 1  B2 rr        	lda (rc)
00174Fr 1  20 rr rr     	jsr put_c_hex
001752r 1  20 rr rr     	jsr put_sp
001755r 1  20 rr rr     	jsr get_s
001758r 1  B0 1A        	bcs @q
00175Ar 1  A9 FF        	lda #$ff	; init scan
00175Cr 1  8D rr rr     	sta scany
00175Fr 1  20 rr rr     	jsr get_par
001762r 1  A9 20 2D rr  	bit_test flags, FLAG_ADD ;test if data
001766r 1  rr           
001767r 1  F0 04        	beq @1
001769r 1  A5 rr        	lda add
00176Br 1  92 rr        	sta (rc)
00176Dr 1               @1:
00176Dr 1  A2 rr 20 rr  	inc_x rc
001771r 1  rr           
001772r 1  80 CA        	bra @0
001774r 1               @q:
001774r 1  A9 00        	lda #0
001776r 1  60           	rts
001777r 1               ;
001777r 1               ;----------------------------------------------------------
001777r 1               ; cmd_fill - fill block address, length, data
001777r 1               ;----------------------------------------------------------
001777r 1               ;
001777r 1               cmd_fill:
001777r 1  20 rr rr     	jsr get_par
00177Ar 1  A2 rr 20 rr  	test_x len
00177Er 1  rr           
00177Fr 1  F0 4A        	beq @q
001781r 1  A5 rr A4 rr  	mov_x2y add, ra
001785r 1  85 rr 84 rr  
001789r 1  A5 rr A4 rr  	mov_x2y len, rb
00178Dr 1  85 rr 84 rr  
001791r 1  A9 FF        	lda #$ff
001793r 1  8D rr rr     	sta count
001796r 1               @0:
001796r 1  EE rr rr     	inc count
001799r 1  D0 05        	bne @1
00179Br 1  A9 2E 20 rr  	print_c '.'
00179Fr 1  rr           
0017A0r 1               @1:
0017A0r 1  A5 rr        	lda data
0017A2r 1  92 rr        	sta (ra)
0017A4r 1  A2 rr 20 rr  	inc_x ra
0017A8r 1  rr           
0017A9r 1  A2 rr 20 rr  	dec_x rb
0017ADr 1  rr           
0017AEr 1  D0 E6        	bne @0
0017B0r 1  A5 rr A4 rr  	mov_x2y add, ra
0017B4r 1  85 rr 84 rr  
0017B8r 1  A5 rr A4 rr  	mov_x2y len, rb
0017BCr 1  85 rr 84 rr  
0017C0r 1  20 rr rr     	jsr add_rb2ra
0017C3r 1  A5 rr A4 rr  	mov_x2y ra, add
0017C7r 1  85 rr 84 rr  
0017CBr 1               @q:
0017CBr 1  4C rr rr     	jmp no_er
0017CEr 1               ;
0017CEr 1               ;----------------------------------------------------------
0017CEr 1               ; get_par - read 3 parameters from cmd_buf and store in
0017CEr 1               ;           add, len, data, rd
0017CEr 1               ; flags[4]==1 if rd ok
0017CEr 1               ; flags[5]==1 if add ok
0017CEr 1               ; flags[6]==1 if len ok
0017CEr 1               ; flags[7]==1 if data ok
0017CEr 1               ;----------------------------------------------------------
0017CEr 1               ;
0017CEr 1               get_par:
0017CEr 1  A9 F0 49 FF  	bit_clear flags, (FLAG_DATA | FLAG_ADD | FLAG_LEN | FLAG_RD)	;%11110000
0017D2r 1  2D rr rr 8D  
0017D6r 1  rr rr        
0017D8r 1  20 rr rr     	jsr scan
0017DBr 1  F0 52        	beq @eq			;q
0017DDr 1  C9 2C        	cmp #','
0017DFr 1  F0 21        	beq @len
0017E1r 1  20 rr rr     	jsr is_hex		;add
0017E4r 1  B0 28        	bcs @cs			;q
0017E6r 1  20 rr rr     	jsr get_hex
0017E9r 1  A5 rr A4 rr  	mov_x2y ra, add
0017EDr 1  85 rr 84 rr  
0017F1r 1  A9 20 0D rr  	bit_set flags, FLAG_ADD
0017F5r 1  rr 8D rr rr  
0017F9r 1  20 rr rr     	jsr scan0
0017FCr 1  F0 75        	beq @q
0017FEr 1  C9 2C        	cmp #','
001800r 1  D0 71        	bne @q
001802r 1               @len:
001802r 1  20 rr rr     	jsr scan
001805r 1  F0 6C        	beq @q
001807r 1  C9 2C        	cmp #','
001809r 1  F0 21        	beq @data
00180Br 1  20 rr rr     	jsr is_hex
00180Er 1               @cs:
00180Er 1  B0 63        	bcs @q
001810r 1  20 rr rr     	jsr get_hex		;len
001813r 1  A5 rr A4 rr  	mov_x2y ra, len
001817r 1  85 rr 84 rr  
00181Br 1  A9 40 0D rr  	bit_set flags, FLAG_LEN
00181Fr 1  rr 8D rr rr  
001823r 1  20 rr rr     	jsr scan0
001826r 1  F0 4B        	beq @q
001828r 1  C9 2C        	cmp #','
00182Ar 1  D0 47        	bne @q
00182Cr 1               @data:
00182Cr 1  20 rr rr     	jsr scan
00182Fr 1               @eq:
00182Fr 1  F0 42        	beq @q
001831r 1  C9 2C        	cmp #','
001833r 1  F0 21        	beq @rd
001835r 1  20 rr rr     	jsr is_hex
001838r 1  B0 39        	bcs @q
00183Ar 1  20 rr rr     	jsr get_hex		;len
00183Dr 1  A5 rr A4 rr  	mov_x2y ra, data
001841r 1  85 rr 84 rr  
001845r 1  A9 80 0D rr  	bit_set flags, FLAG_DATA
001849r 1  rr 8D rr rr  
00184Dr 1  20 rr rr     	jsr scan0
001850r 1  F0 21        	beq @q
001852r 1  C9 2C        	cmp #','
001854r 1  D0 1D        	bne @q
001856r 1               @rd:
001856r 1  20 rr rr     	jsr scan
001859r 1  F0 18        	beq @q
00185Br 1  20 rr rr     	jsr is_hex		;data
00185Er 1  B0 13        	bcs @q
001860r 1  20 rr rr     	jsr get_hex
001863r 1  A5 rr A4 rr  	mov_x2y ra, rd
001867r 1  85 rr 84 rr  
00186Br 1  A9 10 0D rr  	bit_set flags, FLAG_RD
00186Fr 1  rr 8D rr rr  
001873r 1               @q:
001873r 1  AD rr rr     	lda flags
001876r 1  60           	rts
001877r 1               ;
001877r 1               ;----------------------------------------------------------
001877r 1               ; dump - hex/ascii dump memory
001877r 1               ;----------------------------------------------------------
001877r 1               ;
001877r 1               FLAG_OVER	= 2
001877r 1               ;
001877r 1               cmd_dumpa:
001877r 1  A9 01 0D rr  	bit_set flags, FLAG_ASCII
00187Br 1  rr 8D rr rr  
00187Fr 1  80 0A        	bra dump
001881r 1               cmd_dump:
001881r 1  A9 01 49 FF  	bit_clear flags, FLAG_ASCII
001885r 1  2D rr rr 8D  
001889r 1  rr rr        
00188Br 1               dump:
00188Br 1               ;;	jsr put_cr_lf
00188Br 1  20 rr rr     	jsr get_par
00188Er 1  A2 rr 20 rr  	test_x len
001892r 1  rr           
001893r 1  D0 01        	bne @000
001895r 1  60           	rts
001896r 1               @000:
001896r 1  A5 rr        	lda add
001898r 1  29 F0        	and #$f0
00189Ar 1  85 rr        	sta ra
00189Cr 1  A5 rr        	lda add+1
00189Er 1  85 rr        	sta ra+1
0018A0r 1  A9 02 49 FF  	bit_clear flags, FLAG_OVER
0018A4r 1  2D rr rr 8D  
0018A8r 1  rr rr        
0018AAr 1  A5 rr A4 rr  	mov_x2y add, rb
0018AEr 1  85 rr 84 rr  
0018B2r 1  A5 rr A4 rr  	mov_x2y len, rc
0018B6r 1  85 rr 84 rr  
0018BAr 1               ;
0018BAr 1               ; print("      00 01..");
0018BAr 1               ;
0018BAr 1  A9 01 2D rr  	bit_test flags, FLAG_ASCII
0018BEr 1  rr           
0018BFr 1  D0 09        	bne @00
0018C1r 1  A9 rr A0 rr  	print_s msg_n_row
0018C5r 1  20 rr rr     
0018C8r 1  90 07        	bcc @0
0018CAr 1               @00:
0018CAr 1  A9 rr A0 rr  	print_s msg_c_row
0018CEr 1  20 rr rr     
0018D1r 1               ;
0018D1r 1               ; for(t=add0;l>0;t++) {
0018D1r 1               ;   if(t&0x000f==0) print("0000:");
0018D1r 1               ;
0018D1r 1               @0:
0018D1r 1  A2 rr 20 rr  	test_x rc
0018D5r 1  rr           
0018D6r 1  D0 02        	bne @100
0018D8r 1  80 7D        	bra @4
0018DAr 1               @100:
0018DAr 1  A5 rr        	lda ra
0018DCr 1  29 0F        	and #$0f
0018DEr 1  D0 17        	bne @1
0018E0r 1  20 rr rr     	print_cr_lf
0018E3r 1  20 rr rr     	jsr tbreak
0018E6r 1  90 03        	bcc @10
0018E8r 1  4C rr rr     	jmp no_er
0018EBr 1               @10:
0018EBr 1  A5 rr A4 rr  	print_w_hex ra         ; print address
0018EFr 1  20 rr rr     
0018F2r 1  A9 3A        	lda #':'
0018F4r 1  20 rr rr     	jsr put_c
0018F7r 1               ;
0018F7r 1               ; if(t<add) print("   "); else {if(l) { print(data); l--} else exit; }
0018F7r 1               ;
0018F7r 1               @1:
0018F7r 1  A9 02 2D rr  	bit_test flags, FLAG_OVER
0018FBr 1  rr           
0018FCr 1  D0 0D        	bne @2
0018FEr 1  20 rr rr     	jsr cmp_ra2rb
001901r 1  90 3C        	bcc @20   ; print "   "
001903r 1  A9 02 0D rr  	bit_set flags, FLAG_OVER
001907r 1  rr 8D rr rr  
00190Br 1               @2:
00190Br 1  A2 rr 20 rr  	test_x rc
00190Fr 1  rr           
001910r 1  F0 45        	beq @4
001912r 1  20 rr rr     	print_sp   ; print data
001915r 1  B2 rr        	lda (ra)
001917r 1  A8           	tay
001918r 1  A9 01 2D rr  	bit_test flags, FLAG_ASCII
00191Cr 1  rr           
00191Dr 1  D0 06        	bne @2a
00191Fr 1  98           	tya           ; hex
001920r 1  20 rr rr     	jsr put_c_hex
001923r 1  80 13        	bra @2b
001925r 1               @2a:
001925r 1  98           	tya          ; ascii
001926r 1  C9 20        	cmp #' '
001928r 1  90 09        	bcc @2a0
00192Ar 1  C9 80        	cmp #$80
00192Cr 1  B0 05        	bcs @2a0
00192Er 1  20 rr rr     	jsr put_c
001931r 1  80 05        	bra @2b
001933r 1               @2a0:
001933r 1  A9 2E        	lda #'.'
001935r 1  20 rr rr     	jsr put_c
001938r 1               @2b:
001938r 1  A2 rr 20 rr  	dec_x rc
00193Cr 1  rr           
00193Dr 1  80 10        	bra @3
00193Fr 1               @20:
00193Fr 1  20 rr rr     	jsr put_sp
001942r 1  20 rr rr     	jsr put_sp
001945r 1  A9 01 2D rr  	bit_test flags, FLAG_ASCII
001949r 1  rr           
00194Ar 1  D0 03        	bne @3
00194Cr 1  20 rr rr     	jsr put_sp
00194Fr 1               @3:
00194Fr 1  A2 rr 20 rr  	inc_x ra
001953r 1  rr           
001954r 1  4C rr rr     	jmp @0
001957r 1               @4:
001957r 1  20 rr rr     	print_cr_lf
00195Ar 1  A9 01 2D rr  	bit_test flags, FLAG_ASCII
00195Er 1  rr           
00195Fr 1  D0 09        	bne @40
001961r 1  A9 rr A0 rr  	print_s msg_n_row
001965r 1  20 rr rr     
001968r 1  90 07        	bcc @5
00196Ar 1               @40:
00196Ar 1  A9 rr A0 rr  	print_s msg_c_row
00196Er 1  20 rr rr     
001971r 1               @5:
001971r 1  A5 rr A4 rr  	mov_x2y add, ra
001975r 1  85 rr 84 rr  
001979r 1  A5 rr A4 rr  	mov_x2y len, rb
00197Dr 1  85 rr 84 rr  
001981r 1  20 rr rr     	jsr add_rb2ra
001984r 1  A5 rr A4 rr  	mov_x2y ra, add
001988r 1  85 rr 84 rr  
00198Cr 1               @6:
00198Cr 1  A9 01 49 FF  	bit_clear flags, FLAG_ASCII
001990r 1  2D rr rr 8D  
001994r 1  rr rr        
001996r 1               @60:
001996r 1  4C rr rr     	jmp no_er
001999r 1               @7:
001999r 1  4C rr rr     	jmp is_er
00199Cr 1               ;
00199Cr 1               ;**********************************
00199Cr 1               	.if 0
00199Cr 1               ;ra=addr & $fff0
00199Cr 1               	lda addr
00199Cr 1               	and #$f0
00199Cr 1               	sta rc
00199Cr 1               	lda addr+1
00199Cr 1               	sta rc+1
00199Cr 1               ;
00199Cr 1               	movx2y addr, ra
00199Cr 1               	movx2y len, rb
00199Cr 1               	jsr add_rb2ra
00199Cr 1               	lda ra
00199Cr 1               	sta data
00199Cr 1               	and #$f0
00199Cr 1               	sta datard
00199Cr 1               	lda ra+1
00199Cr 1               	sta rd+1
00199Cr 1               
00199Cr 1               toprntbl:
00199Cr 1               	cmp #$21
00199Cr 1               	bcc @c
00199Cr 1               	cmp #$7e
00199Cr 1               	bcs @c
00199Cr 1               	rts
00199Cr 1               @c:
00199Cr 1               	lda #'.'
00199Cr 1               	rts
00199Cr 1               	.endif
00199Cr 1               ;**********************************
00199Cr 1               ;
00199Cr 1               is_er:
00199Cr 1  48           	pha
00199Dr 1  20 rr rr     	jsr put_cr_lf
0019A0r 1  68           	pla
0019A1r 1  60           	rts
0019A2r 1               ;
0019A2r 1               ;
0019A2r 1               ; tbreak - test if break pressed
0019A2r 1               ;
0019A2r 1               mtbrk:
0019A2r 1               tbreak:
0019A2r 1  AD rr rr     	lda breakf
0019A5r 1  F0 0D        	beq @cc
0019A7r 1  9C rr rr     	stz breakf
0019AAr 1  A9 rr A0 rr  	print_s msg_break
0019AEr 1  20 rr rr     
0019B1r 1  38           	sec
0019B2r 1  80 01        	bra @q
0019B4r 1               @cc:
0019B4r 1  18           	clc
0019B5r 1               @q:
0019B5r 1  60               rts
0019B6r 1               ;
0019B6r 1               ;	.include "acia.a65"
0019B6r 1               ;	.include "interrupt.a65"
0019B6r 1               ;	.include "get_put.a65"
0019B6r 1               ;	.include "regs.a65"
0019B6r 1               ;	.include "sd_cf.a65"
0019B6r 1               ;	.include "i2c.a65"
0019B6r 1               ;	.include "at24c.a65"
0019B6r 1               ;	.include "tpin.a65"
0019B6r 1               ;	.include "timers.a65"
0019B6r 1               ;
0019B6r 1               code_end:
0019B6r 1               ;
0019B6r 1               code_len	:= code_end - code_start
0019B6r 1               data_len	:= data_end - data_start
0019B6r 1               ;
0019B6r 1               ;----------------------------------------------------------
0019B6r 1               ;
0019B6r 1               	.segment "VECTORS"
000000r 1               ;
000000r 1               ; nmi
000000r 1               ; reset
000000r 1               ; irq
000000r 1               ;
000000r 1               res_handler	:= mcld
000000r 1  rr rr        	.word nmi_handler
000002r 1  rr rr        	.word res_handler
000004r 1  rr rr        	.word irq_handler
000006r 1               ;
000006r 1               
